diff -Naur xine-lib.ori/include/xine/audio_decoder.h xine-lib/include/xine/audio_decoder.h
--- xine-lib.ori/include/xine/audio_decoder.h	2011-12-17 07:16:56.000000000 +0100
+++ xine-lib/include/xine/audio_decoder.h	2011-12-17 10:47:47.000000000 +0100
@@ -44,7 +44,7 @@
   /*
    * open a new instance of this plugin class
    */
-  audio_decoder_t* (*open_plugin) (audio_decoder_class_t *this, xine_stream_t *stream);
+  audio_decoder_t* (*open_plugin) (audio_decoder_class_t *self, xine_stream_t *stream);
 
   /**
    * @brief short human readable identifier for this plugin class
@@ -67,7 +67,7 @@
    * free all class-related resources
    */
 
-  void (*dispose) (audio_decoder_class_t *this);
+  void (*dispose) (audio_decoder_class_t *self);
 };
 
 #define default_audio_decoder_class_dispose (void (*) (audio_decoder_class_t *this))free
@@ -78,24 +78,24 @@
    * decode data from buf and feed decoded samples to
    * audio output
    */
-  void (*decode_data) (audio_decoder_t *this, buf_element_t *buf);
+  void (*decode_data) (audio_decoder_t *self, buf_element_t *buf);
 
   /*
    * reset decoder after engine flush (prepare for new
    * audio data not related to recently decoded data)
    */
-  void (*reset) (audio_decoder_t *this);
+  void (*reset) (audio_decoder_t *self);
 
   /*
    * inform decoder that a time reference discontinuity has happened.
    * that is, it must forget any currently held pts value
    */
-  void (*discontinuity) (audio_decoder_t *this);
+  void (*discontinuity) (audio_decoder_t *self);
 
   /*
    * close down, free all resources
    */
-  void (*dispose) (audio_decoder_t *this);
+  void (*dispose) (audio_decoder_t *self);
 
   /**
    * @brief Pointer to the loaded plugin node.
diff -Naur xine-lib.ori/include/xine/broadcaster.h xine-lib/include/xine/broadcaster.h
--- xine-lib.ori/include/xine/broadcaster.h	2011-12-17 07:16:56.000000000 +0100
+++ xine-lib/include/xine/broadcaster.h	2011-12-17 10:47:47.000000000 +0100
@@ -30,8 +30,8 @@
 typedef struct broadcaster_s broadcaster_t;
 
 broadcaster_t *_x_init_broadcaster(xine_stream_t *stream, int port) XINE_MALLOC XINE_PROTECTED;
-void _x_close_broadcaster(broadcaster_t *this) XINE_PROTECTED;
-int _x_get_broadcaster_port(broadcaster_t *this) XINE_PROTECTED;
+void _x_close_broadcaster(broadcaster_t *self) XINE_PROTECTED;
+int _x_get_broadcaster_port(broadcaster_t *self) XINE_PROTECTED;
 
 
 #ifdef __cplusplus
diff -Naur xine-lib.ori/include/xine/demux.h xine-lib/include/xine/demux.h
--- xine-lib.ori/include/xine/demux.h	2011-12-17 07:16:56.000000000 +0100
+++ xine-lib/include/xine/demux.h	2011-12-17 10:47:47.000000000 +0100
@@ -49,7 +49,7 @@
   /*
    * open a new instance of this plugin class
    */
-  demux_plugin_t* (*open_plugin) (demux_class_t *this, xine_stream_t *stream, input_plugin_t *input);
+  demux_plugin_t* (*open_plugin) (demux_class_t *self, xine_stream_t *stream, input_plugin_t *input);
 
   /**
    * @brief short human readable identifier for this plugin class
@@ -85,7 +85,7 @@
   /*
    * close down, free all resources
    */
-  void (*dispose) (demux_class_t *this);
+  void (*dispose) (demux_class_t *self);
 };
 
 #define default_demux_class_dispose (void (*) (demux_class_t *this))free
@@ -101,7 +101,7 @@
    * fifos, then return. do not start demux thread (yet)
    */
 
-  void (*send_headers) (demux_plugin_t *this);
+  void (*send_headers) (demux_plugin_t *self);
 
   /*
    * ask demux to seek
@@ -122,7 +122,7 @@
    *                           starting the demuxer)
    */
 
-  int (*seek) (demux_plugin_t *this,
+  int (*seek) (demux_plugin_t *self,
 	       off_t start_pos, int start_time, int playing );
 
   /*
@@ -135,37 +135,37 @@
    * the demux current status
    */
 
-  int (*send_chunk) (demux_plugin_t *this);
+  int (*send_chunk) (demux_plugin_t *self);
 
   /*
    * free resources
    */
 
-  void (*dispose) (demux_plugin_t *this) ;
+  void (*dispose) (demux_plugin_t *self) ;
 
   /*
    * returns DEMUX_OK or  DEMUX_FINISHED
    */
 
-  int (*get_status) (demux_plugin_t *this) ;
+  int (*get_status) (demux_plugin_t *self) ;
 
   /*
    * gets stream length in miliseconds (might be estimated)
    * may return 0 for non-seekable streams
    */
 
-  int (*get_stream_length) (demux_plugin_t *this);
+  int (*get_stream_length) (demux_plugin_t *self);
 
   /*
    * return capabilities of demuxed stream
    */
 
-  uint32_t (*get_capabilities) (demux_plugin_t *this);
+  uint32_t (*get_capabilities) (demux_plugin_t *self);
 
   /*
    * request optional data from input plugin.
    */
-  int (*get_optional_data) (demux_plugin_t *this, void *data, int data_type);
+  int (*get_optional_data) (demux_plugin_t *self, void *data, int data_type);
 
   /*
    * "backwards" link to plugin class
@@ -186,7 +186,7 @@
 #endif
 } ;
 
-#define default_demux_plugin_dispose (void (*) (demux_plugin_t *this))free
+#define default_demux_plugin_dispose (void (*) (demux_plugin_t *self))free
 
 /*
  * possible capabilites a demux plugin can have:
diff -Naur xine-lib.ori/include/xine/input_plugin.h xine-lib/include/xine/input_plugin.h
--- xine-lib.ori/include/xine/input_plugin.h	2011-12-17 07:17:21.000000000 +0100
+++ xine-lib/include/xine/input_plugin.h	2011-12-17 10:47:47.000000000 +0100
@@ -43,7 +43,7 @@
    * create a new instance of this plugin class
    * return NULL if the plugin does'nt handle the given mrl
    */
-  input_plugin_t* (*get_instance) (input_class_t *this, xine_stream_t *stream, const char *mrl);
+  input_plugin_t* (*get_instance) (input_class_t *self, xine_stream_t *stream, const char *mrl);
 
   /**
    * @brief short human readable identifier for this plugin class
@@ -66,28 +66,28 @@
    * ls function, optional: may be NULL
    * return value: NULL => filename is a file, **char=> filename is a dir
    */
-  xine_mrl_t ** (*get_dir) (input_class_t *this, const char *filename, int *nFiles);
+  xine_mrl_t ** (*get_dir) (input_class_t *self, const char *filename, int *nFiles);
 
   /*
    * generate autoplay list, optional: may be NULL
    * return value: list of MRLs
    */
-  char ** (*get_autoplay_list) (input_class_t *this, int *num_files);
+  char ** (*get_autoplay_list) (input_class_t *self, int *num_files);
 
   /*
    * close down, free all resources
    */
-  void (*dispose) (input_class_t *this);
+  void (*dispose) (input_class_t *self);
 
   /*
    * eject/load the media (if possible), optional: may be NULL
    *
    * returns 0 for temporary failures
    */
-  int (*eject_media) (input_class_t *this);
+  int (*eject_media) (input_class_t *self);
 };
 
-#define default_input_class_dispose (void (*) (input_class_t *this))free
+#define default_input_class_dispose (void (*) (input_class_t *self))free
 
 struct input_plugin_s {
 
@@ -95,7 +95,7 @@
    * open the stream
    * return 0 if an error occured
    */
-  int (*open) (input_plugin_t *this);
+  int (*open) (input_plugin_t *self);
 
   /*
    * return capabilities of the current playable entity. See
@@ -113,14 +113,14 @@
    * make a best-effort attempt to seek, e.g. at least
    * relative forward seeking should work.
    */
-  uint32_t (*get_capabilities) (input_plugin_t *this);
+  uint32_t (*get_capabilities) (input_plugin_t *self);
 
   /*
    * read nlen bytes, return number of bytes read
    * Should block until some bytes available for read;
    * a return value of 0 indicates no data available
    */
-  off_t (*read) (input_plugin_t *this, void *buf, off_t nlen);
+  off_t (*read) (input_plugin_t *self, void *buf, off_t nlen);
 
 
   /*
@@ -128,7 +128,7 @@
    * for blocked input sources len must be == blocksize
    * the fifo parameter is only used to get access to the buffer_pool_alloc function
    */
-  buf_element_t *(*read_block)(input_plugin_t *this, fifo_buffer_t *fifo, off_t len);
+  buf_element_t *(*read_block)(input_plugin_t *self, fifo_buffer_t *fifo, off_t len);
 
 
   /*
@@ -136,7 +136,7 @@
    *
    * if seeking failed, -1 is returned
    */
-  off_t (*seek) (input_plugin_t *this, off_t offset, int origin);
+  off_t (*seek) (input_plugin_t *self, off_t offset, int origin);
 
 
   /*
@@ -148,14 +148,14 @@
    * note: only SEEK_SET (0) is currently supported as origin
    * note: may be NULL is not supported
    */
-  off_t (*seek_time) (input_plugin_t *this, int time_offset, int origin);
+  off_t (*seek_time) (input_plugin_t *self, int time_offset, int origin);
 
 
   /*
    * get current position in stream.
    *
    */
-  off_t (*get_current_pos) (input_plugin_t *this);
+  off_t (*get_current_pos) (input_plugin_t *self);
 
 
   /*
@@ -163,7 +163,7 @@
    *
    * note: may be NULL is not supported
    */
-  int (*get_current_time) (input_plugin_t *this);
+  int (*get_current_time) (input_plugin_t *self);
 
 
   /*
@@ -183,7 +183,7 @@
    * absolute or relative play position or possibly calculating the
    * bit rate.
    */
-  off_t (*get_length) (input_plugin_t *this);
+  off_t (*get_length) (input_plugin_t *self);
 
 
   /*
@@ -199,25 +199,25 @@
    * make this function simply return 0 if unsure.
    */
 
-  uint32_t (*get_blocksize) (input_plugin_t *this);
+  uint32_t (*get_blocksize) (input_plugin_t *self);
 
 
   /*
    * return current MRL
    */
-  const char * (*get_mrl) (input_plugin_t *this);
+  const char * (*get_mrl) (input_plugin_t *self);
 
 
   /*
    * request optional data from input plugin.
    */
-  int (*get_optional_data) (input_plugin_t *this, void *data, int data_type);
+  int (*get_optional_data) (input_plugin_t *self, void *data, int data_type);
 
 
   /*
    * close stream, free instance resources
    */
-  void (*dispose) (input_plugin_t *this);
+  void (*dispose) (input_plugin_t *self);
 
   /*
    * "backward" link to input plugin class struct
diff -Naur xine-lib.ori/include/xine/osd.h xine-lib/include/xine/osd.h
--- xine-lib.ori/include/xine/osd.h	2011-12-17 07:16:56.000000000 +0100
+++ xine-lib/include/xine/osd.h	2011-12-17 10:47:47.000000000 +0100
@@ -91,7 +91,7 @@
    * A default palette is initialized (i sugest keeping color 0 as transparent
    * for the sake of simplicity)
    */
-  osd_object_t* (*new_object) (osd_renderer_t *this, int width, int height);
+  osd_object_t* (*new_object) (osd_renderer_t *self, int width, int height);
 
   /*
    * free osd object
@@ -194,7 +194,7 @@
    * loaded fonts are unloaded
    * osd objects are closed
    */
-  void (*close) (osd_renderer_t *this);
+  void (*close) (osd_renderer_t *self);
 
   /*
    * clear an osd object (empty drawing area)
@@ -215,6 +215,10 @@
    */
   int (*show_unscaled) (osd_object_t *osd, int64_t vpts );
 
+
+
+  int (*show_scaled) (osd_object_t *osd, int64_t vpts );
+
   /*
    * see xine.h for defined XINE_OSD_CAP_ values.
    */
diff -Naur xine-lib.ori/include/xine/scratch.h xine-lib/include/xine/scratch.h
--- xine-lib.ori/include/xine/scratch.h	2011-12-17 07:16:56.000000000 +0100
+++ xine-lib/include/xine/scratch.h	2011-12-17 10:47:47.000000000 +0100
@@ -33,11 +33,11 @@
 struct scratch_buffer_s {
 
   void         XINE_FORMAT_PRINTF(2, 0)
-               (*scratch_printf) (scratch_buffer_t *this, const char *format, va_list ap);
+               (*scratch_printf) (scratch_buffer_t *self, const char *format, va_list ap);
 
-  char       **(*get_content) (scratch_buffer_t *this);
+  char       **(*get_content) (scratch_buffer_t *self);
 
-  void         (*dispose) (scratch_buffer_t *this);
+  void         (*dispose) (scratch_buffer_t *self);
 
   char         **lines;
   char         **ordered;
diff -Naur xine-lib.ori/include/xine/spu_decoder.h xine-lib/include/xine/spu_decoder.h
--- xine-lib.ori/include/xine/spu_decoder.h	2011-12-17 07:16:56.000000000 +0100
+++ xine-lib/include/xine/spu_decoder.h	2011-12-17 10:47:47.000000000 +0100
@@ -45,7 +45,7 @@
   /*
    * open a new instance of this plugin class
    */
-  spu_decoder_t* (*open_plugin) (spu_decoder_class_t *this, xine_stream_t *stream);
+  spu_decoder_t* (*open_plugin) (spu_decoder_class_t *self, xine_stream_t *stream);
 
   /**
    * @brief short human readable identifier for this plugin class
@@ -67,7 +67,7 @@
   /*
    * free all class-related resources
    */
-  void (*dispose) (spu_decoder_class_t *this);
+  void (*dispose) (spu_decoder_class_t *self);
 };
 
 #define default_spu_decoder_class_dispose (void (*) (spu_decoder_class_t *this))free
@@ -77,24 +77,24 @@
   /*
    * decode data from buf and feed the overlay to overlay manager
    */
-  void (*decode_data) (spu_decoder_t *this, buf_element_t *buf);
+  void (*decode_data) (spu_decoder_t *self, buf_element_t *buf);
 
   /*
    * reset decoder after engine flush (prepare for new
    * SPU data not related to recently decoded data)
    */
-  void (*reset) (spu_decoder_t *this);
+  void (*reset) (spu_decoder_t *self);
 
   /*
    * inform decoder that a time reference discontinuity has happened.
    * that is, it must forget any currently held pts value
    */
-  void (*discontinuity) (spu_decoder_t *this);
+  void (*discontinuity) (spu_decoder_t *self);
 
   /*
    * close down, free all resources
    */
-  void (*dispose) (spu_decoder_t *this);
+  void (*dispose) (spu_decoder_t *self);
 
   /*
    * When the SPU decoder also handles data used in user interaction,
@@ -106,7 +106,7 @@
    * This function pointer may be NULL, if the plugin does not have
    * such functionality.
    */
-  int  (*get_interact_info) (spu_decoder_t *this, void *data);
+  int  (*get_interact_info) (spu_decoder_t *self, void *data);
 
   /*
    * When the SPU decoder also handles menu overlays for user inter-
diff -Naur xine-lib.ori/include/xine/video_decoder.h xine-lib/include/xine/video_decoder.h
--- xine-lib.ori/include/xine/video_decoder.h	2011-12-17 07:16:56.000000000 +0100
+++ xine-lib/include/xine/video_decoder.h	2011-12-17 10:47:47.000000000 +0100
@@ -45,7 +45,7 @@
   /*
    * open a new instance of this plugin class
    */
-  video_decoder_t* (*open_plugin) (video_decoder_class_t *this, xine_stream_t *stream);
+  video_decoder_t* (*open_plugin) (video_decoder_class_t *self, xine_stream_t *stream);
 
   /**
    * @brief short human readable identifier for this plugin class
@@ -67,7 +67,7 @@
   /*
    * free all class-related resources
    */
-  void (*dispose) (video_decoder_class_t *this);
+  void (*dispose) (video_decoder_class_t *self);
 };
 
 #define default_video_decoder_class_dispose (void (*) (video_decoder_class_t *this))free
@@ -78,29 +78,29 @@
    * decode data from buf and feed decoded frames to
    * video output
    */
-  void (*decode_data) (video_decoder_t *this, buf_element_t *buf);
+  void (*decode_data) (video_decoder_t *self, buf_element_t *buf);
 
   /*
    * reset decoder after engine flush (prepare for new
    * video data not related to recently decoded data)
    */
-  void (*reset) (video_decoder_t *this);
+  void (*reset) (video_decoder_t *self);
 
   /*
    * inform decoder that a time reference discontinuity has happened.
    * that is, it must forget any currently held pts value
    */
-  void (*discontinuity) (video_decoder_t *this);
+  void (*discontinuity) (video_decoder_t *self);
 
   /*
    * flush out any frames that are still stored in the decoder
    */
-  void (*flush) (video_decoder_t *this);
+  void (*flush) (video_decoder_t *self);
 
   /*
    * close down, free all resources
    */
-  void (*dispose) (video_decoder_t *this);
+  void (*dispose) (video_decoder_t *self);
 
   /**
    * @brief Pointer to the loaded plugin node.
diff -Naur xine-lib.ori/include/xine/video_out.h xine-lib/include/xine/video_out.h
--- xine-lib.ori/include/xine/video_out.h	2011-12-17 07:16:56.000000000 +0100
+++ xine-lib/include/xine/video_out.h	2011-12-17 10:47:47.000000000 +0100
@@ -266,7 +266,10 @@
 #define VO_PROP_NOISE_REDUCTION       25
 #define VO_PROP_BUFS_TOTAL            26 /* read-only */
 #define VO_PROP_BUFS_FREE             27 /* read-only */
-#define VO_NUM_PROPERTIES             28
+#define VO_PROP_LAST_PTS              28
+#define VO_PROP_DEINTERLACE_SD        29
+#define VO_PROP_DEINTERLACE_HD        30
+#define VO_NUM_PROPERTIES             31
 
 /* number of colors in the overlay palette. Currently limited to 256
    at most, because some alphablend functions use an 8-bit index into
diff -Naur xine-lib.ori/include/xine/xine_internal.h xine-lib/include/xine/xine_internal.h
--- xine-lib.ori/include/xine/xine_internal.h	2011-12-17 07:16:56.000000000 +0100
+++ xine-lib/include/xine/xine_internal.h	2011-12-17 10:47:47.000000000 +0100
@@ -484,7 +484,7 @@
  * load a specific video output plugin
  */
 
-vo_driver_t *_x_load_video_output_plugin(xine_t *this,
+vo_driver_t *_x_load_video_output_plugin(xine_t *self,
 					 char *id, int visual_type, void *visual) XINE_PROTECTED;
 
 /*
diff -Naur xine-lib.ori/include/xine.h xine-lib/include/xine.h
--- xine-lib.ori/include/xine.h	2011-12-17 07:17:21.000000000 +0100
+++ xine-lib/include/xine.h	2011-12-17 10:47:47.000000000 +0100
@@ -1743,6 +1743,7 @@
 #define XINE_EVENT_MRL_REFERENCE_EXT     13 /* demuxer->frontend: MRL reference(s) for the real stream */
 #define XINE_EVENT_AUDIO_AMP_LEVEL       14 /* report current audio amp level (l/r/mute) */
 #define XINE_EVENT_NBC_STATS             15 /* nbc buffer status */
+#define XINE_EVENT_FRAMERATE_CHANGE      16
 
 
 /* input events coming from frontend */
@@ -1834,6 +1835,9 @@
 /* events generated from post plugins */
 #define XINE_EVENT_POST_TVTIME_FILMMODE_CHANGE   400
 
+#define XINE_EVENT_SET_VIDEO_STREAMTYPE 501
+#define XINE_EVENT_SET_AUDIO_STREAMTYPE 502
+
 /*
  * xine event struct
  */
@@ -1867,6 +1871,12 @@
   char                str[256]; /* might be longer */
 } xine_ui_data_t;
 
+
+typedef struct {
+  int                 pid;
+  int                 streamtype;
+} xine_streamtype_data_t;
+
 /*
  * Send messages to UI. used mostly to report errors.
  */
@@ -1945,6 +1955,11 @@
   int                 type;         /* 0=buffer put, 1=buffer get */
 } xine_nbc_stats_data_t;
 
+
+typedef struct {
+  int64_t             framerate;
+} xine_framerate_data_t;
+
 /*
  * mrl reference data is sent by demuxers when a reference stream is found.
  * this stream just contains pointers (urls) to the real data, which are
@@ -2235,6 +2250,7 @@
 void        xine_osd_set_position  (xine_osd_t *self, int x, int y) XINE_PROTECTED;
 void        xine_osd_show          (xine_osd_t *self, int64_t vpts) XINE_PROTECTED;
 void        xine_osd_show_unscaled (xine_osd_t *self, int64_t vpts) XINE_PROTECTED;
+void        xine_osd_show_scaled   (xine_osd_t *self, int64_t vpts) XINE_PROTECTED;
 void        xine_osd_hide          (xine_osd_t *self, int64_t vpts) XINE_PROTECTED;
 /* empty drawing area */
 void        xine_osd_clear         (xine_osd_t *self) XINE_PROTECTED;
diff -Naur xine-lib.ori/src/demuxers/demux_ts.c xine-lib/src/demuxers/demux_ts.c
--- xine-lib.ori/src/demuxers/demux_ts.c	2011-12-17 07:17:21.000000000 +0100
+++ xine-lib/src/demuxers/demux_ts.c	2011-12-17 10:48:15.000000000 +0100
@@ -146,13 +146,6 @@
 #include <fcntl.h>
 #include <unistd.h>
 #include <string.h>
-#include <arpa/inet.h>
-
-#ifdef HAVE_FFMPEG_AVUTIL_H
-#  include <crc.h>
-#else
-#  include <libavutil/crc.h>
-#endif
 
 #define LOG_MODULE "demux_ts"
 #define LOG_VERBOSE
@@ -189,8 +182,6 @@
 
 #define BUF_SIZE (NPKT_PER_READ * (PKT_SIZE + 4))
 
-#define MAX_PES_BUF_SIZE 2048
-
 #define CORRUPT_PES_THRESHOLD 10
 
 #define NULL_PID 0x1fff
@@ -257,6 +248,10 @@
       HDMV_SPU_INTERACTIVE = 0x91,
       HDMV_SPU_TEXT        = 0x92,
 
+      /* pseudo tags */
+      STREAM_AUDIO_EAC3    = (DESCRIPTOR_EAC3 << 8),
+      STREAM_AUDIO_DTS     = (DESCRIPTOR_DTS  << 8),
+
     } streamType;
 
 #define WRAP_THRESHOLD       270000
@@ -292,13 +287,14 @@
 typedef struct {
   unsigned int     pid;
   fifo_buffer_t   *fifo;
-  uint32_t         size;
   uint32_t         type;
   int64_t          pts;
   buf_element_t   *buf;
   unsigned int     counter;
   uint16_t         descriptor_tag; /* +0x100 for PES stream IDs (no available TS descriptor tag?) */
+  uint8_t          keep;           /* used by demux_ts_dynamic_pmt_*() */
   int              corrupted_pes;
+  int              pes_bytes_left; /* butes left if PES packet size is known */
 
   int              input_normpos;
   int              input_time;
@@ -322,6 +318,8 @@
     char lang[4];
 } demux_ts_audio_track;
 
+
+
 typedef struct {
 
   demux_class_t     demux_class;
@@ -331,15 +329,15 @@
   xine_t           *xine;
   config_values_t  *config;
 
-  const AVCRC      *av_crc;
 } demux_ts_class_t;
 
+
 typedef struct {
   /*
    * The first field must be the "base class" for the plugin!
    */
   demux_plugin_t   demux_plugin;
-
+  demux_ts_class_t *class;
   xine_stream_t   *stream;
 
   config_values_t *config;
@@ -348,8 +346,7 @@
   fifo_buffer_t   *video_fifo;
 
   input_plugin_t  *input;
-
-  demux_ts_class_t *class;
+  unsigned int     read_retries;
 
   int              status;
 
@@ -357,7 +354,6 @@
   int              pkt_size;   /* TS packet size */
   int              pkt_offset; /* TS packet offset */
 
-  int              blockSize;
   int              rate;
   unsigned int     media_num;
   demux_ts_media   media[MAX_PIDS];
@@ -370,6 +366,7 @@
   uint32_t         pmt_pid[MAX_PMTS];
   uint8_t         *pmt[MAX_PMTS];
   uint8_t         *pmt_write_ptr[MAX_PMTS];
+  uint32_t         crc32_table[256];
   uint32_t         last_pmt_crc;
   /*
    * Stuff to do with the transport header. As well as the video
@@ -420,6 +417,169 @@
 } demux_ts_t;
 
 
+static void reset_track_map(fifo_buffer_t *fifo)
+{
+  buf_element_t *buf = fifo->buffer_pool_alloc (fifo);
+
+  buf->type            = BUF_CONTROL_RESET_TRACK_MAP;
+  buf->decoder_info[1] = -1;
+
+  fifo->put (fifo, buf);
+}
+
+/* TJ. dynamic PMT support. The idea is:
+   First, reuse unchanged pids and add new ones.
+   Then, comb out those who are no longer referenced.
+   For example, the Kaffeine dvb frontend preserves original pids but only
+   sends the currently user selected ones, plus matching generated pat/pmt */
+
+static int demux_ts_dynamic_pmt_find (demux_ts_t *this,
+  int pid, int type, unsigned int descriptor_tag) {
+  unsigned int i;
+  demux_ts_media *m;
+  for (i = 0; i < this->media_num; i++) {
+    m = &this->media[i];
+    if ((m->pid == pid) && ((m->type & BUF_MAJOR_MASK) == type)) {
+      /* mark this media decriptor for reuse */
+      m->keep = 1;
+      return i;
+    }
+  }
+  if (i < MAX_PIDS) {
+    /* prepare new media descriptor */
+#ifdef LOG_DYNAMIC_PMT
+    char *name = "";
+    if (type == BUF_VIDEO_BASE) name = "video";
+    else if (type == BUF_AUDIO_BASE) name = "audio";
+    else if (type == BUF_SPU_BASE) name = "subtitle";
+    printf ("demux_ts: new %s pid %d\n", name, pid);
+#endif
+    m = &this->media[i];
+    if (type == BUF_AUDIO_BASE) {
+      /* allocate new audio track as well */
+      if (this->audio_tracks_count >= MAX_AUDIO_TRACKS) {
+	xprintf (this->stream->xine, XINE_VERBOSITY_DEBUG,
+		 "demux_ts: too many audio PIDs, ignoring pid %d\n", pid);
+	return -1;
+      }
+      m->type = type | this->audio_tracks_count;
+      this->audio_tracks[this->audio_tracks_count].pid = pid;
+      this->audio_tracks[this->audio_tracks_count].media_index = i;
+      this->audio_tracks_count++;
+      m->fifo = this->stream->audio_fifo;
+    } else {
+      m->type = type;
+      m->fifo = this->stream->video_fifo;
+    }
+    m->pid = pid;
+
+    if (m->buf) {
+      m->buf->free_buffer(m->buf);
+      m->buf = NULL;
+    }
+    m->counter = INVALID_CC;
+    m->corrupted_pes = 1;
+    m->pts = 0;
+
+    m->descriptor_tag = descriptor_tag;
+
+    m->keep = 1;
+    this->media_num++;
+    return i;
+  }
+  /* table full */
+  return -1;
+}
+
+static void demux_ts_dynamic_pmt_clean (demux_ts_t *this) {
+  int i, count = 0, tracks = 0, spus = 0;
+  /* densify media table */
+  for (i = 0; i < this->media_num; i++) {
+    demux_ts_media *m = &this->media[i];
+    int type = m->type & BUF_MAJOR_MASK;
+    int chan = m->type & 0xff;
+    if (m->keep) {
+      m->keep = 0;
+      if (type == BUF_VIDEO_BASE) {
+        /* adjust single video link */
+        this->videoMedia = count;
+      } else if (type == BUF_AUDIO_BASE) {
+        /* densify audio track table */
+        this->audio_tracks[chan].media_index = count;
+        if (chan > tracks) {
+          m->type = (m->type & ~0xff) | tracks;
+          this->audio_tracks[tracks] = this->audio_tracks[chan];
+        }
+        tracks++;
+      } else if (type == BUF_SPU_BASE) {
+        /* spu language table has already been rebuilt from scratch.
+           Adjust backlinks only */
+        while ((spus < this->spu_langs_count) && (this->spu_langs[spus].pid == m->pid)) {
+          this->spu_langs[spus].media_index = count;
+          spus++;
+        }
+      }
+      if (i > count) {
+        this->media[count] = *m;
+        m->buf = NULL;
+        m->pid = INVALID_PID;
+      }
+      count++;
+    } else {
+      /* drop this no longer needed media descriptor */
+#ifdef LOG_DYNAMIC_PMT
+      char *name = "";
+      if (type == BUF_VIDEO_BASE) name = "video";
+      else if (type == BUF_AUDIO_BASE) name = "audio";
+      else if (type == BUF_SPU_BASE) name = "subtitle";
+      printf ("demux_ts: dropped %s pid %d\n", name, m->pid);
+#endif
+      if (m->buf) {
+        m->buf->free_buffer (m->buf);
+        m->buf = NULL;
+      }
+      m->pid = INVALID_PID;
+    }
+  }
+  if ((tracks < this->audio_tracks_count) && this->audio_fifo) {
+    /* at least 1 audio track removed, tell audio decoder loop */
+    reset_track_map(this->audio_fifo);
+#ifdef LOG_DYNAMIC_PMT
+    printf ("demux_ts: new audio track map\n");
+#endif
+  }
+#ifdef LOG_DYNAMIC_PMT
+  printf ("demux_ts: using %d pids, %d audio %d subtitle channels\n", count, tracks, spus);
+#endif
+  /* adjust table sizes */
+  this->media_num = count;
+  this->audio_tracks_count = tracks;
+  /* should really have no effect */
+  this->spu_langs_count = spus;
+}
+
+static void demux_ts_dynamic_pmt_clear (demux_ts_t *this) {
+  unsigned int i;
+  for (i = 0; i < this->media_num; i++) {
+    if (this->media[i].buf) {
+      this->media[i].buf->free_buffer (this->media[i].buf);
+      this->media[i].buf = NULL;
+    }
+  }
+  this->media_num = 0;
+
+  this->videoPid = INVALID_PID;
+  this->audio_tracks_count = 0;
+  this->spu_pid = INVALID_PID;
+  this->spu_langs_count = 0;
+  this->spu_media = 0;
+
+  this->pcr_pid = INVALID_PID;
+
+  this->last_pmt_crc = 0;
+}
+
+
 static void demux_ts_tbre_reset (demux_ts_t *this) {
   if (this->tbre_time <= TBRE_TIME) {
     this->tbre_pid  = INVALID_PID;
@@ -456,6 +616,28 @@
   this->tbre_lasttime = now;
 }
 
+static void demux_ts_build_crc32_table(demux_ts_t*this) {
+  uint32_t  i, j, k;
+
+  for( i = 0 ; i < 256 ; i++ ) {
+    k = 0;
+    for (j = (i << 24) | 0x800000 ; j != 0x80000000 ; j <<= 1) {
+      k = (k << 1) ^ (((k ^ j) & 0x80000000) ? 0x04c11db7 : 0);
+    }
+    this->crc32_table[i] = k;
+  }
+}
+
+static uint32_t demux_ts_compute_crc32(demux_ts_t*this, uint8_t *data,
+				       int32_t length, uint32_t crc32) {
+  int32_t i;
+
+  for(i = 0; i < length; i++) {
+    crc32 = (crc32 << 8) ^ this->crc32_table[(crc32 >> 24) ^ data[i]];
+  }
+  return crc32;
+}
+
 /* redefine abs as macro to handle 64-bit diffs.
    i guess llabs may not be available everywhere */
 #define abs(x) ( ((x)<0) ? -(x) : (x) )
@@ -566,6 +748,9 @@
       this->spu_pid = lang->pid;
       this->spu_media = lang->media_index;
 
+      /* multiple spu langs can share same media descriptor */
+      this->media[lang->media_index].type =
+        (this->media[lang->media_index].type & ~0xff) | this->current_spu_channel;
 #ifdef TS_LOG
       printf("demux_ts: DVBSUB: selecting lang: %s  page %ld %ld\n",
 	     lang->desc.lang, lang->desc.comp_page_id, lang->desc.aux_page_id);
@@ -620,6 +805,7 @@
   unsigned int i;
   for (i = 0; i < this->media_num; ++i) {
     demux_ts_flush_media(&this->media[i]);
+    this->media[i].corrupted_pes = 1;
   }
 }
 
@@ -635,11 +821,13 @@
  */
 static void demux_ts_parse_pat (demux_ts_t*this, unsigned char *original_pkt,
                                 unsigned char *pkt, unsigned int pusi) {
+#ifdef TS_PAT_LOG
   uint32_t       table_id;
+  uint32_t       version_number;
+#endif
   uint32_t       section_syntax_indicator;
   int32_t        section_length;
   uint32_t       transport_stream_id;
-  uint32_t       version_number;
   uint32_t       current_next_indicator;
   uint32_t       section_number;
   uint32_t       last_section_number;
@@ -670,11 +858,15 @@
 	     "demux_ts: demux error! PAT with invalid pointer\n");
     return;
   }
+#ifdef TS_PAT_LOG
   table_id = (unsigned int)pkt[5] ;
+#endif
   section_syntax_indicator = (((unsigned int)pkt[6] >> 7) & 1) ;
   section_length = (((unsigned int)pkt[6] & 0x03) << 8) | pkt[7];
   transport_stream_id = ((uint32_t)pkt[8] << 8) | pkt[9];
+#ifdef TS_PAT_LOG
   version_number = ((uint32_t)pkt[10] >> 1) & 0x1f;
+#endif
   current_next_indicator = ((uint32_t)pkt[10] & 0x01);
   section_number = (uint32_t)pkt[11];
   last_section_number = (uint32_t)pkt[12];
@@ -712,7 +904,8 @@
   }
 
   /* Check CRC. */
-  calc_crc32 = htonl(av_crc(this->class->av_crc, 0xffffffff, pkt+5, section_length+3-4));
+  calc_crc32 = demux_ts_compute_crc32 (this, pkt+5, section_length+3-4,
+                                       0xffffffff);
   if (crc32 != calc_crc32) {
     xprintf (this->stream->xine, XINE_VERBOSITY_DEBUG,
 	     "demux_ts: demux error! PAT with invalid CRC32: packet_crc32: %.8x calc_crc32: %.8x\n",
@@ -768,11 +961,7 @@
     /* force PMT reparsing when pmt_pid changes */
     if (this->pmt_pid[program_count] != pmt_pid) {
       this->pmt_pid[program_count] = pmt_pid;
-      this->audio_tracks_count = 0;
-      this->last_pmt_crc = 0;
-      this->videoPid = INVALID_PID;
-      this->spu_pid = INVALID_PID;
-      this->pcr_pid = INVALID_PID;
+      demux_ts_dynamic_pmt_clear (this);
 
       if (this->pmt[program_count] != NULL) {
 	free(this->pmt[program_count]);
@@ -823,14 +1012,13 @@
     return 0 ;
   }
 
-  /* packet_len = p[4] << 8 | p[5]; */
   stream_id  = p[3];
-  header_len = p[8];
+  header_len = p[8] + 9;
 
   /* sometimes corruption on header_len causes segfault in memcpy below */
-  if (header_len + 9 > packet_len) {
+  if (header_len > packet_len) {
     xprintf (xine, XINE_VERBOSITY_DEBUG,
-             "demux_ts: illegal value for PES_header_data_length (0x%x)\n", header_len);
+             "demux_ts: illegal value for PES_header_data_length (0x%x)\n", header_len - 9);
     return 0;
   }
 
@@ -841,7 +1029,7 @@
 
   if (p[7] & 0x80) { /* pts avail */
 
-    if (header_len < 5) {
+    if (header_len < 14) {
       return 0;
     }
 
@@ -869,22 +1057,21 @@
 
   m->pts       = pts;
 
-  p += header_len + 9;
-  packet_len -= header_len + 9;
+  m->pes_bytes_left = (int)(p[4] << 8 | p[5]) - header_len + 6;
+  lprintf("PES packet payload left: %d bytes\n", m->pes_bytes_left);
+
+  p += header_len;
+  packet_len -= header_len;
 
   if (m->descriptor_tag == STREAM_VIDEO_VC1) {
-    m->size      = packet_len;
     m->type      = BUF_VIDEO_VC1;
-    return 1;
+    return header_len;
   }
 
   if (m->descriptor_tag == HDMV_SPU_BITMAP) {
-    long payload_len = ((buf[4] << 8) | buf[5]) - header_len - 3;
-
-    m->size = packet_len;
     m->type |= BUF_SPU_HDMV;
-    m->buf->decoder_info[2] = payload_len;
-    return 1;
+    m->buf->decoder_info[2] = m->pes_bytes_left;
+    return header_len;
 
   } else
 
@@ -901,27 +1088,25 @@
      * these "raw" streams may begin with a byte that looks like a stream type.
      * For audio streams, m->type already contains the stream no.
      */
-    if(m->descriptor_tag == HDMV_AUDIO_84_EAC3) {
-      m->size = packet_len;
+    if(m->descriptor_tag == HDMV_AUDIO_84_EAC3 ||
+       m->descriptor_tag == STREAM_AUDIO_EAC3) {
       m->type |= BUF_AUDIO_EAC3;
-      return 1;
+      return header_len;
 
     } else if(m->descriptor_tag == STREAM_AUDIO_AC3) {    /* ac3 - raw */
-      m->size = packet_len;
       m->type |= BUF_AUDIO_A52;
-      return 1;
+      return header_len;
 
     } else if (m->descriptor_tag == HDMV_AUDIO_83_TRUEHD) {
       /* TODO: separate AC3 and TrueHD streams ... */
-      m->size = packet_len;
       m->type |= BUF_AUDIO_A52;
-      return 1;
+      return header_len;
 
-    } else if (m->descriptor_tag == HDMV_AUDIO_82_DTS ||
+    } else if (m->descriptor_tag == STREAM_AUDIO_DTS ||
+               m->descriptor_tag == HDMV_AUDIO_82_DTS ||
                m->descriptor_tag == HDMV_AUDIO_86_DTS_HD_MA ) {
-      m->size = packet_len;
       m->type |= BUF_AUDIO_DTS;
-      return 1;
+      return header_len;
 
     } else if (packet_len < 2) {
       return 0;
@@ -932,45 +1117,42 @@
         return 0;
       }
 
-      m->size    = packet_len - 4;
       m->type   |= BUF_AUDIO_LPCM_BE;
 
       m->buf->decoder_flags  |= BUF_FLAG_SPECIAL;
       m->buf->decoder_info[1] = BUF_SPECIAL_LPCM_CONFIG;
       m->buf->decoder_info[2] = (p[3]<<24) | (p[2]<<16) | (p[1]<<8) | p[0];
 
-      return 1;
+      m->pes_bytes_left -= 4;
+      return header_len + 4;
 
     } else if (m->descriptor_tag == ISO_13818_PES_PRIVATE
 	     && p[0] == 0x20 && p[1] == 0x00) {
       /* DVBSUB */
-      long payload_len = ((buf[4] << 8) | buf[5]) - header_len - 3;
-
-      m->size = packet_len;
       m->type |= BUF_SPU_DVB;
-      m->buf->decoder_info[2] = payload_len;
-      return 1;
+      m->buf->decoder_info[2] = m->pes_bytes_left;
+      return header_len;
 
     } else if (p[0] == 0x0B && p[1] == 0x77) { /* ac3 - syncword */
-      m->size = packet_len;
       m->type |= BUF_AUDIO_A52;
-      return 1;
+      return header_len;
 
     } else if ((p[0] & 0xE0) == 0x20) {
       spu_id = (p[0] & 0x1f);
 
-      m->size      = packet_len-1;
       m->type      = BUF_SPU_DVD + spu_id;
-      return 1;
+      m->pes_bytes_left -= 1;
+      return header_len + 1;
+
     } else if ((p[0] & 0xF0) == 0x80) {
 
       if (packet_len < 4) {
         return 0;
       }
 
-      m->size      = packet_len - 4;
       m->type      |= BUF_AUDIO_A52;
-      return 1;
+      m->pes_bytes_left -= 4;
+      return header_len + 4;
 
 #if 0
     /* commented out: does not set PCM type. Decoder can't handle raw PCM stream without configuration. */
@@ -989,15 +1171,14 @@
         return 0;
       }
 
-      m->size      = packet_len-pcm_offset;
       m->type      |= BUF_AUDIO_LPCM_BE;
-      return 1;
+      m->pes_bytes_left -= pcm_offset;
+      return header_len + pcm_offset;
 #endif
     }
 
   } else if ((stream_id & 0xf0) == 0xe0) {
 
-    m->size      = packet_len;
     switch (m->descriptor_tag) {
     case ISO_11172_VIDEO:
     case ISO_13818_VIDEO:
@@ -1018,11 +1199,10 @@
       m->type      = BUF_VIDEO_MPEG;
       break;
     }
-    return 1;
+    return header_len;
 
   } else if ((stream_id & 0xe0) == 0xc0) {
 
-    m->size      = packet_len;
     switch (m->descriptor_tag) {
     case  ISO_11172_AUDIO:
     case  ISO_13818_AUDIO:
@@ -1042,7 +1222,7 @@
       m->type      |= BUF_AUDIO_MPEG;
       break;
     }
-    return 1;
+    return header_len;
 
   } else {
 #ifdef TS_LOG
@@ -1103,7 +1283,9 @@
     /* allocate the buffer here, as pes_header needs a valid buf for dvbsubs */
     m->buf = m->fifo->buffer_pool_alloc(m->fifo);
 
-    if (!demux_ts_parse_pes_header(this->stream->xine, m, ts, len)) {
+    int pes_header_len = demux_ts_parse_pes_header(this->stream->xine, m, ts, len);
+
+    if (pes_header_len <= 0) {
       m->buf->free_buffer(m->buf);
       m->buf = NULL;
 
@@ -1113,8 +1295,10 @@
     } else {
 
       m->corrupted_pes = 0;
-      memcpy(m->buf->mem, ts+len-m->size, m->size);
-      m->buf->size = m->size;
+
+      /* skip PES header */
+      ts  += pes_header_len;
+      len -= pes_header_len;
 
       update_extra_info(this, m);
 
@@ -1124,41 +1308,29 @@
       if (m->pid == this->tbre_pid)
         demux_ts_tbre_update (this, TBRE_MODE_AUDIO_PTS, m->pts);
     }
+  }
 
-  } else if (!m->corrupted_pes) { /* no pus -- PES packet continuation */
+  if (!m->corrupted_pes) {
 
-    if ((m->buf->size + len) > MAX_PES_BUF_SIZE) {
+    if ((m->buf->size + len) > m->buf->max_size) {
+      m->pes_bytes_left -= m->buf->size;
       demux_ts_send_buffer(m, 0);
       m->buf = m->fifo->buffer_pool_alloc(m->fifo);
     }
+
     memcpy(m->buf->mem + m->buf->size, ts, len);
     m->buf->size += len;
-  }
-}
-
-/*
- * Create a buffer for a PES stream.
- */
-static void demux_ts_pes_new(demux_ts_t*this,
-                             unsigned int mediaIndex,
-                             unsigned int pid,
-                             fifo_buffer_t *fifo,
-			     uint16_t descriptor) {
 
-  demux_ts_media *m = &this->media[mediaIndex];
-
-  /* new PID seen - initialise stuff */
-  m->pid = pid;
-  m->fifo = fifo;
-
-  if (m->buf != NULL) m->buf->free_buffer(m->buf);
-  m->buf = NULL;
-  m->counter = INVALID_CC;
-  m->descriptor_tag = descriptor;
-  m->corrupted_pes = 1;
+    if (m->pes_bytes_left > 0 && m->buf->size >= m->pes_bytes_left) {
+      /* PES payload complete */
+      m->pes_bytes_left -= m->buf->size;
+      demux_ts_flush_media(m);
+      /* skip rest data - there shouldn't be any */
+      m->corrupted_pes = 1;
+    }
+  }
 }
 
-
 /* Find the first ISO 639 language descriptor (tag 10) and
  * store the 3-char code in dest, nullterminated.  If no
  * code is found, zero out dest.
@@ -1249,11 +1421,13 @@
                                 unsigned int   pusi,
                                 uint32_t       program_count) {
 
+#ifdef TS_PMT_LOG
   uint32_t       table_id;
+  uint32_t       version_number;
+#endif
   uint32_t       section_syntax_indicator;
   uint32_t       section_length = 0; /* to calm down gcc */
   uint32_t       program_number;
-  uint32_t       version_number;
   uint32_t       current_next_indicator;
   uint32_t       section_number;
   uint32_t       last_section_number;
@@ -1265,9 +1439,10 @@
   unsigned char *stream;
   unsigned int	 i;
   int		 count;
-  uint8_t	*ptr = NULL;
+  char		*ptr = NULL;
   unsigned char  len;
   unsigned int   offset=0;
+  int            mi;
 
   /*
    * A new section should start with the payload unit start
@@ -1282,11 +1457,15 @@
     this->pmt[program_count] = (uint8_t *) calloc(4096, sizeof(unsigned char));
     this->pmt_write_ptr[program_count] = this->pmt[program_count];
 
+#ifdef TS_PMT_LOG
     table_id                  =  pkt[5] ;
+#endif
     section_syntax_indicator  = (pkt[6] >> 7) & 0x01;
     section_length            = (((uint32_t) pkt[6] << 8) | pkt[7]) & 0x03ff;
     program_number            =  ((uint32_t) pkt[8] << 8) | pkt[9];
+#ifdef TS_PMT_LOG
     version_number            = (pkt[10] >> 1) & 0x1f;
+#endif
     current_next_indicator    =  pkt[10] & 0x01;
     section_number            =  pkt[11];
     last_section_number       =  pkt[12];
@@ -1381,9 +1560,9 @@
   crc32 |= (uint32_t) this->pmt[program_count][section_length+3-1] ;
 
   /* Check CRC. */
-  calc_crc32 = htonl(av_crc(this->class->av_crc, 0xffffffff,
-			    this->pmt[program_count], section_length+3-4));
-
+  calc_crc32 = demux_ts_compute_crc32 (this,
+                                       this->pmt[program_count],
+                                       section_length+3-4, 0xffffffff);
   if (crc32 != calc_crc32) {
     xprintf (this->stream->xine, XINE_VERBOSITY_DEBUG,
 	     "demux_ts: demux error! PMT with invalid CRC32: packet_crc32: %#.8x calc_crc32: %#.8x\n",
@@ -1414,10 +1593,12 @@
    * PMT has changed (e.g. an IPTV streamer that's just changed its source),
    * we'll get new PIDs that we should follow.
    */
-  this->audio_tracks_count = 0;
   this->videoPid = INVALID_PID;
   this->spu_pid = INVALID_PID;
 
+  this->spu_langs_count = 0;
+  reset_track_map(this->video_fifo);
+
   /*
    * ES definitions start here...we are going to learn upto one video
    * PID and one audio PID.
@@ -1443,7 +1624,6 @@
   /*
    * Extract the elementary streams.
    */
-  this->spu_langs_count = 0;
   while (section_length > 0) {
     unsigned int stream_info_length;
 
@@ -1470,9 +1650,12 @@
 #ifdef TS_PMT_LOG
         printf ("demux_ts: PMT video pid 0x%.4x type %2.2x\n", pid, stream[0]);
 #endif
-        demux_ts_pes_new(this, this->media_num, pid, this->video_fifo,stream[0]);
-	this->videoMedia = this->media_num;
-	this->videoPid = pid;
+
+        mi = demux_ts_dynamic_pmt_find (this, pid, BUF_VIDEO_BASE, stream[0]);
+        if (mi >= 0) {
+	  this->videoMedia = mi;
+	  this->videoPid = pid;
+	}
       }
 
       break;
@@ -1481,18 +1664,17 @@
     case ISO_13818_PART7_AUDIO:
     case ISO_14496_PART3_AUDIO:
       if (this->audio_tracks_count < MAX_AUDIO_TRACKS) {
-        if (apid_check(this, pid) < 0) {
+
+        mi = demux_ts_dynamic_pmt_find (this, pid, BUF_AUDIO_BASE, stream[0]);
+        if (mi >= 0) {
 #ifdef TS_PMT_LOG
-            printf ("demux_ts: PMT audio pid 0x%.4x type %2.2x\n", pid, stream[0]);
+          printf ("demux_ts: PMT audio pid 0x%.4x type %2.2x\n", pid, stream[0]);
 #endif
-            demux_ts_pes_new(this, this->media_num, pid, this->audio_fifo,stream[0]);
-            this->audio_tracks[this->audio_tracks_count].pid = pid;
-            this->audio_tracks[this->audio_tracks_count].media_index = this->media_num;
-            this->media[this->media_num].type = this->audio_tracks_count;
-            demux_ts_get_lang_desc(this, this->audio_tracks[this->audio_tracks_count].lang,
-			       stream + 5, stream_info_length);
-            this->audio_tracks_count++;
+          demux_ts_get_lang_desc (this,
+            this->audio_tracks[this->media[mi].type & 0xff].lang,
+            stream + 5, stream_info_length);
         }
+
       }
       break;
     case ISO_13818_PRIVATE:
@@ -1511,28 +1693,23 @@
       break;
     case ISO_13818_PES_PRIVATE:
       for (i = 5; i < coded_length; i += stream[i+1] + 2) {
-        if (((stream[i] == DESCRIPTOR_AC3) || (stream[i] == DESCRIPTOR_EAC3)) &&
-	    (this->audio_tracks_count < MAX_AUDIO_TRACKS)) {
-          if (apid_check(this, pid) < 0) {
+
+        if ((stream[i] == DESCRIPTOR_AC3) || (stream[i] == DESCRIPTOR_EAC3) || (stream[i] == DESCRIPTOR_DTS)) {
+          mi = demux_ts_dynamic_pmt_find (this, pid, BUF_AUDIO_BASE,
+            stream[i] == DESCRIPTOR_AC3 ? STREAM_AUDIO_AC3 :
+            stream[i] == DESCRIPTOR_DTS ? STREAM_AUDIO_DTS :
+            STREAM_AUDIO_EAC3);
+          if (mi >= 0) {
 #ifdef TS_PMT_LOG
             printf ("demux_ts: PMT AC3 audio pid 0x%.4x type %2.2x\n", pid, stream[0]);
 #endif
-            if (stream[i] == DESCRIPTOR_AC3)
-              demux_ts_pes_new(this, this->media_num, pid,
-                               this->audio_fifo, STREAM_AUDIO_AC3);
-            else
-              demux_ts_pes_new(this, this->media_num, pid,
-                               this->audio_fifo, HDMV_AUDIO_84_EAC3);
-
-            this->audio_tracks[this->audio_tracks_count].pid = pid;
-            this->audio_tracks[this->audio_tracks_count].media_index = this->media_num;
-            this->media[this->media_num].type = this->audio_tracks_count;
-            demux_ts_get_lang_desc(this, this->audio_tracks[this->audio_tracks_count].lang,
-                                   stream + 5, stream_info_length);
-            this->audio_tracks_count++;
+            demux_ts_get_lang_desc (this,
+              this->audio_tracks[this->media[mi].type & 0xff].lang,
+              stream + 5, stream_info_length);
             break;
           }
         }
+
         /* Teletext */
         else if (stream[i] == DESCRIPTOR_TELETEXT)
           {
@@ -1550,6 +1727,10 @@
 	else if (stream[i] == DESCRIPTOR_DVBSUB)
 	  {
 	    int pos;
+
+	    mi = demux_ts_dynamic_pmt_find (this, pid, BUF_SPU_BASE, stream[0]);
+	    if (mi < 0) break;
+
             for (pos = i + 2;
 		 pos + 8 <= i + 2 + stream[i + 1]
 		   && this->spu_langs_count < MAX_SPU_LANGS;
@@ -1567,9 +1748,7 @@
 		lang->desc.aux_page_id =
 		  (stream[pos + 6] << 8) | stream[pos + 7];
 		lang->pid = pid;
-		lang->media_index = this->media_num;
-		this->media[this->media_num].type = no;
-		demux_ts_pes_new(this, this->media_num, pid, this->video_fifo, stream[0]);
+		lang->media_index = mi;
 		demux_send_special_spu_buf( this, BUF_SPU_DVB, no );
 #ifdef TS_LOG
 		printf("demux_ts: DVBSUB: pid 0x%.4x: %s  page %ld %ld type %2.2x\n",
@@ -1604,15 +1783,17 @@
 	    break;
 	  }
 
+	  mi = demux_ts_dynamic_pmt_find (this, pid, BUF_SPU_BASE, stream[0]);
+	  if (mi < 0) break;
+
+
 	  demux_ts_spu_lang *lang = &this->spu_langs[this->spu_langs_count];
 
 	  memset(lang->desc.lang, 0, sizeof(lang->desc.lang));
 	  /*memcpy(lang->desc.lang, &stream[pos], 3);*/
 	  /*lang->desc.lang[3] = 0;*/
 	  lang->pid = pid;
-	  lang->media_index = this->media_num;
-	  this->media[this->media_num].type = this->spu_langs_count;
-	  demux_ts_pes_new(this, this->media_num, pid, this->video_fifo, stream[0]);
+	  lang->media_index = mi;
 	  demux_send_special_spu_buf( this, BUF_SPU_HDMV, this->spu_langs_count );
 	  this->spu_langs_count++;
 #ifdef TS_PMT_LOG
@@ -1631,43 +1812,43 @@
  * if is does, we tag this as an audio stream.
  * FIXME: This will need expanding if we ever see a DTS or other media format here.
  */
-        if ((this->audio_tracks_count < MAX_AUDIO_TRACKS) && (stream[0] >= 0x80) ) {
-          if (apid_check(this,pid) < 0) {
-            uint32_t format_identifier=0;
-            demux_ts_get_reg_desc(this, &format_identifier,
-                    stream + 5, stream_info_length);
-            /* If no format identifier, assume A52 */
-            if (( format_identifier == 0x41432d33) ||
-                ( format_identifier == 0) ||
-                ((format_identifier == 0x48444d56 || this->hdmv>0) && stream[0] == HDMV_AUDIO_80_PCM) /* BluRay PCM */) {
-
-                demux_ts_pes_new(this, this->media_num, pid, this->audio_fifo, stream[0]);
-                this->audio_tracks[this->audio_tracks_count].pid = pid;
-                this->audio_tracks[this->audio_tracks_count].media_index = this->media_num;
-                this->media[this->media_num].type = this->audio_tracks_count;
-                demux_ts_get_lang_desc(this, this->audio_tracks[this->audio_tracks_count].lang,
-                                       stream + 5, stream_info_length);
-                this->audio_tracks_count++;
-                break;
-            }
+      if ((this->audio_tracks_count < MAX_AUDIO_TRACKS) && (stream[0] >= 0x80) ) {
+
+        uint32_t format_identifier=0;
+        demux_ts_get_reg_desc(this, &format_identifier, stream + 5, stream_info_length);
+        /* If no format identifier, assume A52 */
+        if (( format_identifier == 0x41432d33) ||
+            ( format_identifier == 0) ||
+            ((format_identifier == 0x48444d56 || this->hdmv>0) && stream[0] == HDMV_AUDIO_80_PCM) /* BluRay PCM */) {
+
+          mi = demux_ts_dynamic_pmt_find (this, pid, BUF_AUDIO_BASE, stream[0]);
+          if (mi >= 0) {
+            demux_ts_get_lang_desc (this,
+              this->audio_tracks[this->media[mi].type & 0xff].lang,
+              stream + 5, stream_info_length);
+#ifdef TS_PMT_LOG
+            printf ("demux_ts: PMT audio pid 0x%.4x type %2.2x\n", pid, stream[0]);
+#endif
+            break;
+          }
         }
-      } else {
+      }
 #ifdef TS_PMT_LOG
-        printf ("demux_ts: PMT unknown stream_type: 0x%.2x pid: 0x%.4x\n",
-                stream[0], pid);
+      printf ("demux_ts: PMT unknown stream_type: 0x%.2x pid: 0x%.4x\n",
+              stream[0], pid);
 
-        for (i = 5; i < coded_length; i++)
-          printf ("%.2x ", stream[i]);
-        printf ("\n");
+      for (i = 5; i < coded_length; i++)
+        printf ("%.2x ", stream[i]);
+      printf ("\n");
 #endif
-      }
       break;
     }
-    this->media_num++;
     stream += coded_length;
     section_length -= coded_length;
   }
 
+  demux_ts_dynamic_pmt_clean (this);
+
   /*
    * Get the current PCR PID.
    */
@@ -1801,8 +1982,19 @@
       this->frame_pos = this->input->get_current_pos (this->input);
 
       read_length = this->input->read(this->input, this->buf,
-				      this->pkt_size * NPKT_PER_READ);
-      if (read_length < 0 || read_length % this->pkt_size) {
+                                      this->pkt_size * NPKT_PER_READ);
+
+      if (read_length < 0) {
+        xprintf (this->stream->xine, XINE_VERBOSITY_DEBUG,
+                 "demux_ts: read returned %d\n", read_length);
+        if (this->read_retries > 2)
+          this->status = DEMUX_FINISHED;
+        this->read_retries++;
+        return NULL;
+      }
+      this->read_retries = 0;
+
+      if (read_length % this->pkt_size) {
 	xprintf (this->stream->xine, XINE_VERBOSITY_DEBUG,
 		 "demux_ts: read returned %d bytes (not a multiple of %d!)\n",
 		 read_length, this->pkt_size);
@@ -1821,6 +2013,7 @@
        */
 
       if (this->npkt_read == 0) {
+        demux_ts_flush(this);
 	xprintf (this->stream->xine, XINE_VERBOSITY_DEBUG, "demux_ts: read 0 packets\n");
 	this->status = DEMUX_FINISHED;
 	return NULL;
@@ -1953,7 +2146,9 @@
   unsigned int   sync_byte;
   unsigned int   transport_error_indicator;
   unsigned int   payload_unit_start_indicator;
+#ifdef TS_HEADER_LOG
   unsigned int   transport_priority;
+#endif
   unsigned int   pid;
   unsigned int   transport_scrambling_control;
   unsigned int   adaptation_field_control;
@@ -1971,7 +2166,9 @@
   sync_byte                      = originalPkt[0];
   transport_error_indicator      = (originalPkt[1]  >> 7) & 0x01;
   payload_unit_start_indicator   = (originalPkt[1] >> 6) & 0x01;
+#ifdef TS_HEADER_LOG
   transport_priority             = (originalPkt[1] >> 5) & 0x01;
+#endif
   pid                            = ((originalPkt[1] << 8) |
 				    originalPkt[2]) & 0x1fff;
   transport_scrambling_control   = (originalPkt[3] >> 6)  & 0x03;
@@ -2143,15 +2340,8 @@
 
     case XINE_EVENT_PIDS_CHANGE:
 
-      this->videoPid    = INVALID_PID;
-      this->pcr_pid     = INVALID_PID;
-      this->audio_tracks_count = 0;
-      this->media_num   = 0;
+      demux_ts_dynamic_pmt_clear(this);
       this->send_newpts = 1;
-      this->spu_pid     = INVALID_PID;
-      this->spu_media   = 0;
-      this->spu_langs_count= 0;
-      this->last_pmt_crc = 0;
       _x_demux_control_start (this->stream);
       break;
 
@@ -2236,6 +2426,8 @@
 
   this->send_newpts = 1;
 
+  demux_ts_build_crc32_table (this);
+
   this->status = DEMUX_OK ;
 
   this->scrambled_npids   = 0;
@@ -2284,6 +2476,7 @@
     m->buf            = NULL;
     m->counter        = INVALID_CC;
     m->corrupted_pes  = 1;
+    m->pts            = 0;
   }
 
   if( !playing ) {
@@ -2335,23 +2528,36 @@
     {
     case DEMUX_OPTIONAL_DATA_AUDIOLANG:
       if ((channel >= 0) && (channel < this->audio_tracks_count)) {
-        if(this->audio_tracks[channel].lang)
+        if (this->audio_tracks[channel].lang[0]) {
           strcpy(str, this->audio_tracks[channel].lang);
-        else
-          sprintf(str, "%3i", _x_get_audio_channel(this->stream));
+        } else {
+          /* input plugin may know the language */
+          if (this->input->get_capabilities(this->input) & INPUT_CAP_AUDIOLANG)
+            return DEMUX_OPTIONAL_UNSUPPORTED;
+          sprintf(str, "%3i", channel);
+        }
+        return DEMUX_OPTIONAL_SUCCESS;
       }
       else {
-        snprintf(str, XINE_LANG_MAX, "%3i", _x_get_audio_channel(this->stream));
+        strcpy(str, "none");
       }
-      return DEMUX_OPTIONAL_SUCCESS;
+      return DEMUX_OPTIONAL_UNSUPPORTED;
 
     case DEMUX_OPTIONAL_DATA_SPULANG:
       if (channel>=0 && channel<this->spu_langs_count) {
-        memcpy(str, this->spu_langs[channel].desc.lang, 3);
-	str[3] = 0;}
-      else
+        if (this->spu_langs[channel].desc.lang[0]) {
+          strcpy(str, this->spu_langs[channel].desc.lang);
+        } else {
+          /* input plugin may know the language */
+          if (this->input->get_capabilities(this->input) & INPUT_CAP_SPULANG)
+            return DEMUX_OPTIONAL_UNSUPPORTED;
+          sprintf(str, "%3i", channel);
+        }
+        return DEMUX_OPTIONAL_SUCCESS;
+      } else {
         strcpy(str, "none");
-      return DEMUX_OPTIONAL_SUCCESS;
+      }
+      return DEMUX_OPTIONAL_UNSUPPORTED;
 
     default:
       return DEMUX_OPTIONAL_UNSUPPORTED;
@@ -2385,6 +2591,7 @@
   return ts_detected;
 }
 
+
 static demux_plugin_t *open_plugin (demux_class_t *class_gen,
 				    xine_stream_t *stream,
 				    input_plugin_t *input) {
@@ -2488,6 +2695,7 @@
 /*
  * ts demuxer class
  */
+
 static void *init_class (xine_t *xine, void *data) {
 
   demux_ts_class_t     *this;
@@ -2497,23 +2705,15 @@
   this->xine   = xine;
 
   this->demux_class.open_plugin     = open_plugin;
-  this->demux_class.description     = N_("MPEG Transport Stream demuxer");
-  this->demux_class.identifier      = "MPEG_TS";
-  this->demux_class.mimetypes       = "video/mp2t: m2t: MPEG2 transport stream;";
-
-  /* accept dvb streams; also handle the special dvbs,dvbt and dvbc
-   * mrl formats: the content is exactly the same but the input plugin
-   * uses a different tuning algorithm [Pragma]
-   */
-  this->demux_class.extensions      = "ts m2t trp m2ts mts dvb:// dvbs:// dvbc:// dvbt://";
+  this->demux_class.description = N_("TS stream demux plugin");;
+  this->demux_class.identifier  = "MPEG_TS";
+  this->demux_class.mimetypes   = "video/mp2t: m2t: MPEG2 transport stream;";
+  this->demux_class.extensions  = "ts m2t trp m2ts mts dvb:// dvbs:// dvbc:// dvbt:// enigma:/";;
   this->demux_class.dispose         = default_demux_class_dispose;
 
-  this->av_crc = av_crc_get_table(AV_CRC_32_IEEE);
-
   return this;
 }
 
-
 /*
  * exported plugin catalog entry
  */
diff -Naur xine-lib.ori/src/input/Makefile.am xine-lib/src/input/Makefile.am
--- xine-lib.ori/src/input/Makefile.am	2011-12-17 07:17:21.000000000 +0100
+++ xine-lib/src/input/Makefile.am	2011-12-17 10:47:47.000000000 +0100
@@ -80,7 +80,8 @@
 	xineplug_inp_net.la \
 	$(in_pvr) \
 	$(in_dvb) \
-	xineplug_inp_cdda.la
+	xineplug_inp_cdda.la \
+	xineplug_inp_enigma.la
 
 
 xineplug_inp_file_la_SOURCES = input_file.c
@@ -144,3 +145,6 @@
 
 xineplug_inp_pvr_la_SOURCES = input_pvr.c
 xineplug_inp_pvr_la_LIBADD = $(XINE_LIB) $(PTHREAD_LIBS) $(LTLIBINTL)
+
+xineplug_inp_enigma_la_SOURCES = input_enigma.c net_buf_ctrl.c
+xineplug_inp_enigma_la_LIBADD = $(XINE_LIB) $(PTHREAD_LIBS) $(LTLIBINTL)
diff -Naur xine-lib.ori/src/input/input_enigma.c xine-lib/src/input/input_enigma.c
--- xine-lib.ori/src/input/input_enigma.c	1970-01-01 01:00:00.000000000 +0100
+++ xine-lib/src/input/input_enigma.c	2011-12-17 10:49:39.000000000 +0100
@@ -0,0 +1,621 @@
+/*
+ * Copyright (C) 2000-2003 the xine project
+ *
+ * This file is part of xine, a free video player.
+ *
+ * xine is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * xine is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <sys/stat.h>
+#include <errno.h>
+
+#define LOG_MODULE "input_enigma"
+#define LOG_VERBOSE
+/*
+#define LOG
+*/
+
+#include <xine/input_plugin.h>
+#include "net_buf_ctrl.h"
+
+#define ENIGMA_ABS_FIFO_DIR     "/tmp"
+#define DEFAULT_PTS_START       1500
+#define BUFSIZE                 2048
+#define FILE_FLAGS O_RDONLY
+#define FIFO_PUT                0
+
+typedef struct enigma_input_plugin_s enigma_input_plugin_t;
+
+struct enigma_input_plugin_s {
+  input_plugin_t      input_plugin;
+  xine_stream_t      *stream;
+  int                 fh;
+  char               *mrl;
+  off_t               curpos;
+  char                seek_buf[BUFSIZE];
+  xine_t             *xine;
+  int                 last_disc_type;
+  nbc_t              *nbc;
+};
+
+typedef struct {
+  input_class_t     input_class;
+  xine_t           *xine;
+} enigma_input_class_t;
+
+
+/* Put callback the fifo mutex is locked */
+static void enigma_nbc_put_cb (fifo_buffer_t *fifo, buf_element_t *buf, void *this_gen) {
+  nbc_t *this = (nbc_t*)this_gen;
+  int64_t progress = 0;
+  int64_t video_p = 0;
+  int64_t audio_p = 0;
+  int has_video, has_audio;
+
+  lprintf("enter enigma_nbc_put_cb\n");
+  pthread_mutex_lock(&this->mutex);
+
+  if ((buf->type & BUF_MAJOR_MASK) != BUF_CONTROL_BASE) {
+
+    if (this->enabled) {
+
+      nbc_compute_fifo_length(this, fifo, buf, FIFO_PUT);
+
+      if (this->buffering) {
+
+        has_video = _x_stream_info_get(this->stream, XINE_STREAM_INFO_HAS_VIDEO);
+        has_audio = _x_stream_info_get(this->stream, XINE_STREAM_INFO_HAS_AUDIO);
+        /* restart playing if high_water_mark is reached by all fifos
+         * do not restart if has_video and has_audio are false to avoid
+         * a yoyo effect at the beginning of the stream when these values
+         * are not yet known.
+         *
+         * be sure that the next buffer_pool_alloc() call will not deadlock,
+         * we need at least 2 buffers (see buffer.c)
+         */
+//printf("this->video_last_pts %lld   this->audio_last_pts %lld\n", this->video_last_pts, this->audio_last_pts);
+        int64_t first_pts = this->video_first_pts>this->audio_first_pts?this->video_first_pts:this->audio_first_pts;
+        int64_t last_pts = this->video_last_pts<this->audio_last_pts?this->video_last_pts:this->audio_last_pts;
+//printf("AAA first_pts %lld  last_pts %lld\n", first_pts, last_pts);
+        if ( has_video && has_audio && (last_pts-first_pts)>DEFAULT_PTS_START ) {
+          this->progress = 100;
+          //report_progress (this->stream, 100);
+          this->buffering = 0;
+          nbc_set_speed_normal(this);
+        }
+        else if ((((!has_video) || (this->video_fifo_length > this->high_water_mark)) &&
+             ((!has_audio) || (this->audio_fifo_length > this->high_water_mark)) &&
+             (has_video || has_audio))) {
+
+          this->progress = 100;
+          //report_progress (this->stream, 100);
+          this->buffering = 0;
+
+          xprintf(this->stream->xine, XINE_VERBOSITY_DEBUG, "\nnet_buf_ctrl: enigma_nbc_put_cb: stops buffering\n");
+
+          nbc_set_speed_normal(this);
+
+          this->high_water_mark += this->high_water_mark / 2;
+
+        } else {
+          /*  compute the buffering progress
+           *    50%: video
+           *    50%: audio */
+          video_p = ((this->video_fifo_length * 50) / this->high_water_mark);
+          if (video_p > 50) video_p = 50;
+          audio_p = ((this->audio_fifo_length * 50) / this->high_water_mark);
+          if (audio_p > 50) audio_p = 50;
+
+          if ((has_video) && (has_audio)) {
+            progress = video_p + audio_p;
+          } else if (has_video) {
+            progress = 2 * video_p;
+          } else {
+            progress = 2 * audio_p;
+          }
+
+          /* if the progress can't be computed using the fifo length,
+             use the number of buffers */
+          if (!progress) {
+            video_p = this->video_fifo_fill;
+            audio_p = this->audio_fifo_fill;
+            progress = (video_p > audio_p) ? video_p : audio_p;
+          }
+
+          if (progress > this->progress) {
+            //report_progress (this->stream, progress);
+            this->progress = progress;
+          }
+        }
+      }
+      //if(this->stream->xine->verbosity >= XINE_VERBOSITY_DEBUG)
+      //  display_stats(this);
+
+      //report_stats(this, 0);
+    }
+  } else {
+
+    switch (buf->type) {
+      case BUF_CONTROL_START:
+        lprintf("BUF_CONTROL_START\n");
+        if (!this->enabled) {
+          /* a new stream starts */
+          xprintf(this->stream->xine, XINE_VERBOSITY_DEBUG, "\nnet_buf_ctrl: enigma_nbc_put_cb: starts buffering\n");
+          this->enabled           = 1;
+          this->buffering         = 1;
+          this->video_first_pts   = 0;
+          this->video_last_pts    = 0;
+          this->audio_first_pts   = 0;
+          this->audio_last_pts    = 0;
+          this->video_fifo_length = 0;
+          this->audio_fifo_length = 0;
+         // nbc_set_speed_pause(this);
+          this->progress = 0;
+		 // this->progress = 100;
+          //report_progress (this->stream, progress);
+        }
+        break;
+      case BUF_CONTROL_NOP:
+        if (!(buf->decoder_flags & BUF_FLAG_END_USER) &&
+            !(buf->decoder_flags & BUF_FLAG_END_STREAM)) {
+          break;
+        }
+        /* fall through */
+      case BUF_CONTROL_END:
+      case BUF_CONTROL_QUIT:
+        lprintf("BUF_CONTROL_END\n");
+        if (this->enabled) {
+          /* end of stream :
+           *   - disable the nbc
+           *   - unpause the engine if buffering
+           */
+          this->enabled = 0;
+
+          lprintf("DISABLE netbuf\n");
+
+          if (this->buffering) {
+            this->buffering = 0;
+            this->progress = 100;
+            //report_progress (this->stream, this->progress);
+
+            xprintf(this->stream->xine, XINE_VERBOSITY_DEBUG, "\nnet_buf_ctrl: enigma_nbc_put_cb: stops buffering\n");
+
+            nbc_set_speed_normal(this);
+          }
+        }
+        break;
+
+      case BUF_CONTROL_NEWPTS:
+        /* discontinuity management */
+        if (fifo == this->video_fifo) {
+          this->video_in_disc++;
+          xprintf(this->stream->xine, XINE_VERBOSITY_DEBUG,
+		  "\nnet_buf_ctrl: enigma_nbc_put_cb video disc %d\n", this->video_in_disc);
+        } else {
+          this->audio_in_disc++;
+          xprintf(this->stream->xine, XINE_VERBOSITY_DEBUG,
+		  "\nnet_buf_ctrl: enigma_nbc_put_cb audio disc %d\n", this->audio_in_disc);
+        }
+        break;
+    }
+
+    if (fifo == this->video_fifo) {
+      this->video_fifo_free = fifo->buffer_pool_num_free;
+      this->video_fifo_size = fifo->fifo_data_size;
+    } else {
+      this->audio_fifo_free = fifo->buffer_pool_num_free;
+      this->audio_fifo_size = fifo->fifo_data_size;
+    }
+  }
+  pthread_mutex_unlock(&this->mutex);
+  lprintf("exit enigma_nbc_put_cb\n");
+}
+
+nbc_t *enigma_nbc_init (xine_stream_t *stream) {
+
+  nbc_t *this = calloc(1, sizeof (nbc_t));
+  fifo_buffer_t *video_fifo = stream->video_fifo;
+  fifo_buffer_t *audio_fifo = stream->audio_fifo;
+  
+  
+  double video_fifo_factor, audio_fifo_factor;
+  cfg_entry_t *entry;
+
+  lprintf("enigma_nbc_init\n");
+  pthread_mutex_init (&this->mutex, NULL);
+
+  this->stream              = stream;
+  this->video_fifo          = video_fifo;
+  this->audio_fifo          = audio_fifo;
+
+  /* when the FIFO sizes are increased compared to the default configuration,
+   * apply a factor to the high water mark */
+  entry = stream->xine->config->lookup_entry(stream->xine->config, "engine.buffers.video_num_buffers");
+  /* No entry when no video output */
+  if (entry)
+    video_fifo_factor = (double)video_fifo->buffer_pool_capacity / (double)entry->num_default;
+  else
+    video_fifo_factor = 1.0;
+  entry = stream->xine->config->lookup_entry(stream->xine->config, "engine.buffers.audio_num_buffers");
+  /* When there's no audio output, there's no entry */
+  if (entry)
+    audio_fifo_factor = (double)audio_fifo->buffer_pool_capacity / (double)entry->num_default;
+  else
+    audio_fifo_factor = 1.0;
+  /* use the smaller factor */
+  if (video_fifo_factor < audio_fifo_factor)
+    this->high_water_mark = (double)DEFAULT_HIGH_WATER_MARK * video_fifo_factor;
+  else
+    this->high_water_mark = (double)DEFAULT_HIGH_WATER_MARK * audio_fifo_factor;
+
+  video_fifo->register_alloc_cb(video_fifo, nbc_alloc_cb, this);
+  video_fifo->register_put_cb(video_fifo, enigma_nbc_put_cb, this);
+  video_fifo->register_get_cb(video_fifo, nbc_get_cb, this);
+
+  audio_fifo->register_alloc_cb(audio_fifo, nbc_alloc_cb, this);
+  audio_fifo->register_put_cb(audio_fifo, enigma_nbc_put_cb, this);
+  audio_fifo->register_get_cb(audio_fifo, nbc_get_cb, this);
+
+  return this;
+}
+
+void enigma_nbc_close (nbc_t *this) {
+  fifo_buffer_t *video_fifo = this->stream->video_fifo;
+  fifo_buffer_t *audio_fifo = this->stream->audio_fifo;
+  xine_t        *xine       = this->stream->xine;
+
+  xprintf(xine, XINE_VERBOSITY_DEBUG, "\nnet_buf_ctrl: enigma_nbc_close\n");
+
+  /* unregister all fifo callbacks */
+  /* do not lock the mutex to avoid deadlocks if a decoder calls fifo->get() */
+  video_fifo->unregister_alloc_cb(video_fifo, nbc_alloc_cb);
+  video_fifo->unregister_put_cb(video_fifo, enigma_nbc_put_cb);
+  video_fifo->unregister_get_cb(video_fifo, nbc_get_cb);
+
+  audio_fifo->unregister_alloc_cb(audio_fifo, nbc_alloc_cb);
+  audio_fifo->unregister_put_cb(audio_fifo, enigma_nbc_put_cb);
+  audio_fifo->unregister_get_cb(audio_fifo, nbc_get_cb);
+
+  /* now we are sure that nobody will call a callback */
+  this->stream->xine->clock->set_option (this->stream->xine->clock, CLOCK_SCR_ADJUSTABLE, 1);
+
+  pthread_mutex_destroy(&this->mutex);
+  free (this);
+  xprintf(xine, XINE_VERBOSITY_DEBUG, "\nnet_buf_ctrl: enigma_nbc_close: done\n");
+}
+
+static off_t enigma_read_abort(xine_stream_t *stream, int fd, char *buf, off_t todo)
+{
+  off_t ret;
+
+  while (1)
+  {
+    /*
+     * System calls are not a thread cancellation point in Linux
+     * pthreads.  However, the RT signal sent to cancel the thread
+     * will cause recv() to return with EINTR, and we can manually
+     * check cancellation.
+     */
+    pthread_testcancel();
+    ret = _x_read_abort(stream, fd, buf, todo);
+    pthread_testcancel();
+
+    if (ret < 0
+        && (errno == EINTR
+          || errno == EAGAIN))
+    {
+      continue;
+    }
+
+    break;
+  }
+
+  return ret;
+}
+
+static off_t enigma_plugin_read (input_plugin_t *this_gen,
+				void *buf_gen, off_t len) {
+
+  enigma_input_plugin_t  *this = (enigma_input_plugin_t *) this_gen;
+  uint8_t *buf = (uint8_t *)buf_gen;
+  off_t n, total = 0;
+#ifdef LOG_READ
+  lprintf ("reading %lld bytes...\n", len);
+#endif
+
+  if( len > 0 )
+  {
+    int retries = 0;
+    do
+    {
+      n = enigma_read_abort (this->stream, this->fh, (char *)&buf[total], len-total);
+      //n = _x_io_file_read (this->stream, this->fh, &buf[total], len - total);
+      if (0 == n)
+        lprintf("read 0, retries: %d\n", retries);
+    }
+    while (0 == n
+           && _x_continue_stream_processing(this->stream)
+           && 200 > retries++); // 200 * 50ms
+#ifdef LOG_READ
+    lprintf ("got %lld bytes (%lld/%lld bytes read)\n", n, total, len);
+#endif
+    if (n < 0)
+    {
+      _x_message(this->stream, XINE_MSG_READ_ERROR, NULL);
+      return 0;
+    }
+
+    this->curpos += n;
+    total += n;
+  }
+
+  return total;
+
+}
+
+static buf_element_t *enigma_plugin_read_block (input_plugin_t *this_gen, fifo_buffer_t *fifo,
+					       off_t todo) {
+
+  off_t                 total_bytes;
+  /* enigma_input_plugin_t  *this = (enigma_input_plugin_t *) this_gen; */
+  buf_element_t         *buf = fifo->buffer_pool_alloc (fifo);
+
+  if (todo > buf->max_size)
+    todo = buf->max_size;
+  if (todo < 0) {
+    buf->free_buffer (buf);
+    return NULL;
+  }
+
+  buf->content = buf->mem;
+  buf->type = BUF_DEMUX_BLOCK;
+
+  total_bytes = enigma_plugin_read (this_gen, (char*)buf->content, todo);
+
+  if (total_bytes != todo) {
+    buf->free_buffer (buf);
+    return NULL;
+  }
+
+  buf->size = total_bytes;
+
+  return buf;
+}
+
+/* forward reference */
+static off_t enigma_plugin_seek (input_plugin_t *this_gen, off_t offset, int origin) {
+
+  enigma_input_plugin_t  *this = (enigma_input_plugin_t *) this_gen;
+
+  printf ("seek %"PRId64" offset, %d origin...\n", offset, origin);
+
+  if ((origin == SEEK_CUR) && (offset >= 0)) {
+
+    for (;((int)offset) - BUFSIZE > 0; offset -= BUFSIZE) {
+      if( this_gen->read (this_gen, this->seek_buf, BUFSIZE) <= 0 )
+        return this->curpos;
+    }
+
+    this_gen->read (this_gen, this->seek_buf, offset);
+  }
+
+  if (origin == SEEK_SET) {
+
+    if (offset < this->curpos) {
+
+      //if( this->curpos <= this->preview_size )
+      //  this->curpos = offset;
+      //else
+        xprintf (this->xine, XINE_VERBOSITY_LOG,
+                 _("stdin: cannot seek back! (%" PRIdMAX " > %" PRIdMAX ")\n"),
+                 (intmax_t)this->curpos, (intmax_t)offset);
+        printf ("stdin: cannot seek back! (%" PRIdMAX " > %" PRIdMAX ")\n",
+                 (intmax_t)this->curpos, (intmax_t)offset);
+
+    } else {
+      offset -= this->curpos;
+
+      for (;((int)offset) - BUFSIZE > 0; offset -= BUFSIZE) {
+        if( this_gen->read (this_gen, this->seek_buf, BUFSIZE) <= 0 )
+          return this->curpos;
+      }
+
+      this_gen->read (this_gen, this->seek_buf, offset);
+    }
+  }
+
+  return this->curpos;
+}
+
+static off_t enigma_plugin_get_length(input_plugin_t *this_gen) {
+  return 0;
+}
+
+static uint32_t enigma_plugin_get_capabilities(input_plugin_t *this_gen) {
+
+  return INPUT_CAP_PREVIEW;
+}
+
+static uint32_t enigma_plugin_get_blocksize(input_plugin_t *this_gen) {
+
+  return 0;
+}
+
+static off_t enigma_plugin_get_current_pos (input_plugin_t *this_gen){
+  enigma_input_plugin_t *this = (enigma_input_plugin_t *) this_gen;
+
+  return this->curpos;
+}
+
+static const char* enigma_plugin_get_mrl (input_plugin_t *this_gen) {
+  enigma_input_plugin_t *this = (enigma_input_plugin_t *) this_gen;
+
+  return this->mrl;
+}
+
+static void enigma_plugin_dispose (input_plugin_t *this_gen ) {
+  enigma_input_plugin_t *this = (enigma_input_plugin_t *) this_gen;
+
+  if (this->nbc) {
+    enigma_nbc_close (this->nbc);
+  }
+
+  if (this->fh != -1)
+    close(this->fh);
+
+  free (this->mrl);
+  free (this);
+}
+
+static int enigma_plugin_get_optional_data (input_plugin_t *this_gen,
+					   void *data, int data_type) {
+  enigma_input_plugin_t *this = (enigma_input_plugin_t *) this_gen;
+
+  switch (data_type)
+  {
+  case INPUT_OPTIONAL_DATA_PREVIEW:
+    /* just fake what mpeg_pes demuxer expects */
+    memcpy (data, "\x00\x00\x01\xe0\x00\x03\x80\x00\x00", 9);
+    return 9;
+  case INPUT_OPTIONAL_DATA_DEMUXER:
+    {
+      char **tmp = (char**)data;
+      *tmp = "mpeg-ts";
+    }
+    return 0;
+  }
+
+  return INPUT_OPTIONAL_UNSUPPORTED;
+}
+
+static int enigma_plugin_open (input_plugin_t *this_gen ) {
+  enigma_input_plugin_t *this = (enigma_input_plugin_t *) this_gen;
+
+  printf ("trying to open '%s'...\n", this->mrl);
+
+  if (this->fh == -1) {
+    int err = 0;
+    char *filename = (char *)ENIGMA_ABS_FIFO_DIR "/ENIGMA_FIFO";
+    this->fh = open (filename, FILE_FLAGS);
+
+    printf("filename '%s'\n", filename);
+
+    if (this->fh == -1) {
+      xprintf (this->xine, XINE_VERBOSITY_LOG, _("enigma_fifo: failed to open '%s'\n"), filename);
+      printf ("enigma_fifo: failed to open '%s'\n", filename);
+      return 0;
+    }
+
+  }
+
+  /*
+   * mrl accepted and opened successfully at this point
+   *
+   * => create plugin instance
+   */
+
+  this->curpos          = 0;
+
+  return 1;
+}
+
+static input_plugin_t *enigma_class_get_instance (input_class_t *class_gen,
+						 xine_stream_t *stream, const char *data) {
+
+  enigma_input_class_t  *class = (enigma_input_class_t *) class_gen;
+  enigma_input_plugin_t *this;
+  char                 *mrl = strdup(data);
+  int                   fh;
+
+  if (!strncasecmp(mrl, "enigma:/", 8)) {
+    lprintf("Enigma plugin\n");
+  } else {
+    free(mrl);
+    return NULL;
+  }
+
+  /*
+   * mrl accepted and opened successfully at this point
+   *
+   * => create plugin instance
+   */
+
+  this       = calloc(1, sizeof(enigma_input_plugin_t));
+
+  this->stream = stream;
+  this->curpos = 0;
+  this->mrl    = mrl;
+  this->fh     = -1;
+  this->xine   = class->xine;
+
+  this->input_plugin.open              = enigma_plugin_open;
+  this->input_plugin.get_capabilities  = enigma_plugin_get_capabilities;
+  this->input_plugin.read              = enigma_plugin_read;
+  this->input_plugin.read_block        = enigma_plugin_read_block;
+  this->input_plugin.seek              = enigma_plugin_seek;
+  this->input_plugin.get_current_pos   = enigma_plugin_get_current_pos;
+  this->input_plugin.get_length        = enigma_plugin_get_length;
+  this->input_plugin.get_blocksize     = enigma_plugin_get_blocksize;
+  this->input_plugin.get_mrl           = enigma_plugin_get_mrl;
+  this->input_plugin.dispose           = enigma_plugin_dispose;
+  this->input_plugin.get_optional_data = enigma_plugin_get_optional_data;
+  this->input_plugin.input_class       = class_gen;
+
+  /*
+   * buffering control
+   */
+  this->nbc    = enigma_nbc_init (this->stream);
+
+  return &this->input_plugin;
+}
+
+
+static void *init_class (xine_t *xine, void *data) {
+
+  enigma_input_class_t  *this;
+
+  this = calloc(1, sizeof (enigma_input_class_t));
+
+  this->xine   = xine;
+
+  this->input_class.get_instance       = enigma_class_get_instance;
+  this->input_class.identifier         = "enigma";
+  this->input_class.description        = N_("ENIGMA2PC display device plugin");
+  this->input_class.get_dir            = NULL;
+  this->input_class.get_autoplay_list  = NULL;
+  this->input_class.dispose            = default_input_class_dispose;
+  this->input_class.eject_media        = NULL;
+
+  return this;
+}
+
+/*
+ * exported plugin catalog entry
+ */
+
+const plugin_info_t xine_plugin_info[] EXPORTED = {
+  /* type, API, "name", version, special_info, init_function */
+  { PLUGIN_INPUT, 18, "enigma", XINE_VERSION_CODE, NULL, init_class },
+  { PLUGIN_NONE, 0, "", 0, NULL, NULL }
+};
diff -Naur xine-lib.ori/src/input/net_buf_ctrl.c xine-lib/src/input/net_buf_ctrl.c
--- xine-lib.ori/src/input/net_buf_ctrl.c	2011-12-17 07:17:21.000000000 +0100
+++ xine-lib/src/input/net_buf_ctrl.c	2011-12-17 10:47:47.000000000 +0100
@@ -40,60 +40,12 @@
 
 #include "net_buf_ctrl.h"
 
-#define DEFAULT_HIGH_WATER_MARK 5000 /* in 1/1000 s */
-
 #define FULL_FIFO_MARK             5 /* buffers free */
 
 #define FIFO_PUT                   0
 #define FIFO_GET                   1
 
-struct nbc_s {
-
-  xine_stream_t   *stream;
-
-  int              buffering;
-  int              enabled;
 
-  int              progress;
-  fifo_buffer_t   *video_fifo;
-  fifo_buffer_t   *audio_fifo;
-  int              video_fifo_fill;
-  int              audio_fifo_fill;
-  int              video_fifo_free;
-  int              audio_fifo_free;
-  int64_t          video_fifo_length;     /* in ms */
-  int64_t          audio_fifo_length;     /* in ms */
-  int64_t          video_fifo_length_int; /* in ms */
-  int64_t          audio_fifo_length_int; /* in ms */
-
-  int64_t          high_water_mark;
-  /* bitrate */
-  int64_t          video_last_pts;
-  int64_t          audio_last_pts;
-  int64_t          video_first_pts;
-  int64_t          audio_first_pts;
-  int64_t          video_fifo_size;
-  int64_t          audio_fifo_size;
-  int64_t          video_br;
-  int64_t          audio_br;
-
-  int              video_in_disc;
-  int              audio_in_disc;
-
-  pthread_mutex_t  mutex;
-
-  /* follow live dvb delivery speed.
-     0 = fix disabled
-     1 = play at normal speed
-     2 = play 0.5% slower to fill video fifo
-     3 = play 0.5% faster to empty video fifo
-     4..6 = same as 1..3 but watch audio fifo instead
-     7 = pause */
-  int dvbspeed;
-  int dvbs_center, dvbs_width, dvbs_audio_fill, dvbs_video_fill;
-  int64_t dvbs_audio_in, dvbs_audio_out;
-  int64_t dvbs_video_in, dvbs_video_out;
-};
 
 static void report_progress (xine_stream_t *stream, int p) {
 
@@ -110,7 +62,7 @@
   xine_event_send (stream, &event);
 }
 
-static void nbc_set_speed_pause (nbc_t *this) {
+void nbc_set_speed_pause (nbc_t *this) {
   xine_stream_t *stream = this->stream;
 
   xprintf(stream->xine, XINE_VERBOSITY_DEBUG, "\nnet_buf_ctrl: nbc_set_speed_pause\n");
@@ -118,7 +70,7 @@
   stream->xine->clock->set_option (stream->xine->clock, CLOCK_SCR_ADJUSTABLE, 0);
 }
 
-static void nbc_set_speed_normal (nbc_t *this) {
+void nbc_set_speed_normal (nbc_t *this) {
   xine_stream_t *stream = this->stream;
 
   xprintf(stream->xine, XINE_VERBOSITY_DEBUG, "\nnet_buf_ctrl: nbc_set_speed_normal\n");
@@ -126,7 +78,7 @@
   stream->xine->clock->set_option (stream->xine->clock, CLOCK_SCR_ADJUSTABLE, 1);
 }
 
-static void dvbspeed_init (nbc_t *this) {
+void dvbspeed_init (nbc_t *this) {
   const char *mrl;
   if (this->stream && this->stream->input_plugin) {
     mrl = this->stream->input_plugin->get_mrl (this->stream->input_plugin);
@@ -171,7 +123,7 @@
   }
 }
 
-static void dvbspeed_close (nbc_t *this) {
+void dvbspeed_close (nbc_t *this) {
   if (((0xec >> this->dvbspeed) & 1) && this->stream)
     _x_set_fine_speed (this->stream, XINE_FINE_SPEED_NORMAL);
 #ifdef LOG_DVBSPEED
@@ -180,7 +132,7 @@
   this->dvbspeed = 0;
 }
 
-static void dvbspeed_put (nbc_t *this, fifo_buffer_t * fifo, buf_element_t *b) {
+void dvbspeed_put (nbc_t *this, fifo_buffer_t * fifo, buf_element_t *b) {
   int64_t diff, *last;
   int *fill;
   int used, mode;
@@ -256,7 +208,7 @@
   }
 }
 
-static void dvbspeed_get (nbc_t *this, fifo_buffer_t * fifo, buf_element_t *b) {
+void dvbspeed_get (nbc_t *this, fifo_buffer_t * fifo, buf_element_t *b) {
   int64_t diff, *last;
   int *fill;
   int used, mode;
@@ -363,7 +315,7 @@
  *    else
  *      use the the first and the last pts of the fifo
  */
-static void nbc_compute_fifo_length(nbc_t *this,
+void nbc_compute_fifo_length(nbc_t *this,
                                     fifo_buffer_t *fifo,
                                     buf_element_t *buf,
                                     int action) {
@@ -465,7 +417,7 @@
 }
 
 /* Alloc callback */
-static void nbc_alloc_cb (fifo_buffer_t *fifo, void *this_gen) {
+void nbc_alloc_cb (fifo_buffer_t *fifo, void *this_gen) {
   nbc_t *this = (nbc_t*)this_gen;
 
   lprintf("enter nbc_alloc_cb\n");
@@ -489,7 +441,7 @@
 
 /* Put callback
  * the fifo mutex is locked */
-static void nbc_put_cb (fifo_buffer_t *fifo,
+void nbc_put_cb (fifo_buffer_t *fifo,
                         buf_element_t *buf, void *this_gen) {
   nbc_t *this = (nbc_t*)this_gen;
   int64_t progress = 0;
@@ -653,7 +605,7 @@
 
 /* Get callback
  * the fifo mutex is locked */
-static void nbc_get_cb (fifo_buffer_t *fifo,
+void nbc_get_cb (fifo_buffer_t *fifo,
 			buf_element_t *buf, void *this_gen) {
   nbc_t *this = (nbc_t*)this_gen;
 
diff -Naur xine-lib.ori/src/input/net_buf_ctrl.h xine-lib/src/input/net_buf_ctrl.h
--- xine-lib.ori/src/input/net_buf_ctrl.h	2011-12-17 07:16:56.000000000 +0100
+++ xine-lib/src/input/net_buf_ctrl.h	2011-12-17 10:47:47.000000000 +0100
@@ -25,10 +25,71 @@
 
 #include <xine/xine_internal.h>
 
+struct nbc_s {
+
+  xine_stream_t   *stream;
+
+  int              buffering;
+  int              enabled;
+
+  int              progress;
+  fifo_buffer_t   *video_fifo;
+  fifo_buffer_t   *audio_fifo;
+  int              video_fifo_fill;
+  int              audio_fifo_fill;
+  int              video_fifo_free;
+  int              audio_fifo_free;
+  int64_t          video_fifo_length;     /* in ms */
+  int64_t          audio_fifo_length;     /* in ms */
+  int64_t          video_fifo_length_int; /* in ms */
+  int64_t          audio_fifo_length_int; /* in ms */
+
+  int64_t          high_water_mark;
+  /* bitrate */
+  int64_t          video_last_pts;
+  int64_t          audio_last_pts;
+  int64_t          video_first_pts;
+  int64_t          audio_first_pts;
+  int64_t          video_fifo_size;
+  int64_t          audio_fifo_size;
+  int64_t          video_br;
+  int64_t          audio_br;
+
+  int              video_in_disc;
+  int              audio_in_disc;
+
+  pthread_mutex_t  mutex;
+
+  /* follow live dvb delivery speed.
+     0 = fix disabled
+     1 = play at normal speed
+     2 = play 0.5% slower to fill video fifo
+     3 = play 0.5% faster to empty video fifo
+     4..6 = same as 1..3 but watch audio fifo instead
+     7 = pause */
+  int dvbspeed;
+  int dvbs_center, dvbs_width, dvbs_audio_fill, dvbs_video_fill;
+  int64_t dvbs_audio_in, dvbs_audio_out;
+  int64_t dvbs_video_in, dvbs_video_out;
+};
+
+
 typedef struct nbc_s nbc_t;
 
 nbc_t *nbc_init (xine_stream_t *xine) XINE_MALLOC;
 
 void nbc_close (nbc_t *this);
+void nbc_set_speed_pause (nbc_t *this);
+void nbc_set_speed_normal (nbc_t *this);
+void dvbspeed_init (nbc_t *this);
+void dvbspeed_close (nbc_t *this);
+void dvbspeed_put (nbc_t *this, fifo_buffer_t * fifo, buf_element_t *b);
+void dvbspeed_get (nbc_t *this, fifo_buffer_t * fifo, buf_element_t *b);
+void nbc_put_cb (fifo_buffer_t *fifo, buf_element_t *buf, void *this_gen);
+void nbc_compute_fifo_length(nbc_t *this, fifo_buffer_t *fifo, buf_element_t *buf, int action);
+void nbc_alloc_cb (fifo_buffer_t *fifo, void *this_gen);
+void nbc_get_cb (fifo_buffer_t *fifo, buf_element_t *buf, void *this_gen);
+
+#define DEFAULT_HIGH_WATER_MARK 5000 /* in 1/1000 s */
 
 #endif
diff -Naur xine-lib.ori/src/video_dec/libvdpau/vdpau_h264.c xine-lib/src/video_dec/libvdpau/vdpau_h264.c
--- xine-lib.ori/src/video_dec/libvdpau/vdpau_h264.c	2011-12-17 07:16:56.000000000 +0100
+++ xine-lib/src/video_dec/libvdpau/vdpau_h264.c	2011-12-17 10:47:47.000000000 +0100
@@ -378,7 +378,7 @@
   event.data_length = sizeof(data);
   data.width = this->width;
   data.height = this->height;
-  data.aspect = this->ratio;
+  data.aspect = this->ratio>1.77?3:2;
   xine_event_send( this->stream, &event );
 
   switch(this->completed_pic->sps_nal->sps.profile_idc) {
diff -Naur xine-lib.ori/src/video_dec/libvdpau/vdpau_mpeg12.c xine-lib/src/video_dec/libvdpau/vdpau_mpeg12.c
--- xine-lib.ori/src/video_dec/libvdpau/vdpau_mpeg12.c	2011-12-17 07:16:56.000000000 +0100
+++ xine-lib/src/video_dec/libvdpau/vdpau_mpeg12.c	2011-12-17 10:47:47.000000000 +0100
@@ -401,7 +401,7 @@
     event.data_length = sizeof(data);
     data.width = sequence->coded_width;
     data.height = sequence->coded_height;
-    data.aspect = sequence->ratio;
+    data.aspect = sequence->aspect_ratio_information;
     xine_event_send( this_gen->stream, &event );
   }
   else if ( sequence->have_header == 2 && sequence->reported_video_step != sequence->video_step ) {
diff -Naur xine-lib.ori/src/video_dec/libvdpau/vdpau_mpeg4.c xine-lib/src/video_dec/libvdpau/vdpau_mpeg4.c
--- xine-lib.ori/src/video_dec/libvdpau/vdpau_mpeg4.c	2011-12-17 07:16:56.000000000 +0100
+++ xine-lib/src/video_dec/libvdpau/vdpau_mpeg4.c	2011-12-17 10:47:47.000000000 +0100
@@ -322,7 +322,7 @@
   event.data_length = sizeof(data);
   data.width = sequence->coded_width;
   data.height = sequence->coded_height;
-  data.aspect = sequence->ratio;
+  data.aspect = sequence->ratio>1.77?3:2;
   xine_event_send( this_gen->stream, &event );
 }
 
diff -Naur xine-lib.ori/src/video_dec/libvdpau/vdpau_vc1.c xine-lib/src/video_dec/libvdpau/vdpau_vc1.c
--- xine-lib.ori/src/video_dec/libvdpau/vdpau_vc1.c	2011-12-17 07:16:56.000000000 +0100
+++ xine-lib/src/video_dec/libvdpau/vdpau_vc1.c	2011-12-17 10:47:47.000000000 +0100
@@ -238,7 +238,7 @@
     event.data_length = sizeof(data);
     data.width = sequence->coded_width;
     data.height = sequence->coded_height;
-    data.aspect = sequence->ratio;
+    data.aspect = sequence->ratio>1.77?3:2;
     xine_event_send( this_gen->stream, &event );
   }
 }
diff -Naur xine-lib.ori/src/video_out/video_out_vdpau.c xine-lib/src/video_out/video_out_vdpau.c
--- xine-lib.ori/src/video_out/video_out_vdpau.c	2011-12-17 07:17:21.000000000 +0100
+++ xine-lib/src/video_out/video_out_vdpau.c	2011-12-17 10:47:47.000000000 +0100
@@ -677,7 +677,14 @@
     ovl_rect.x1 = ovl->x + ovl->width;
     ovl_rect.y1 = ovl->y + ovl->height;
 
-    if (!ovl->unscaled) {
+    if (ovl->unscaled==2) {
+      ovl_rect.x0 = 0;
+      ovl_rect.y0 = 0;
+      ovl_rect.x1 = this->sc.gui_width;
+      ovl_rect.y1 = this->sc.gui_height;
+      this->ovl_changed = 1;
+    }
+    else if (ovl->unscaled==0) {
       double rx, ry;
       if (ovl->extent_width > 0 && ovl->extent_height > 0) {
         rx = (double)ovl->extent_width;
@@ -2008,6 +2015,12 @@
       this->deinterlace = value;
       vdpau_set_deinterlace( this_gen );
       break;
+    case VO_PROP_DEINTERLACE_SD:
+      this->deinterlace_method_sd = value;
+      break;
+    case VO_PROP_DEINTERLACE_HD:
+      this->deinterlace_method_hd = value;
+      break;
     case VO_PROP_ZOOM_X:
       if ((value >= XINE_VO_ZOOM_MIN) && (value <= XINE_VO_ZOOM_MAX)) {
         this->zoom_x = value;
diff -Naur xine-lib.ori/src/xine-engine/osd.c xine-lib/src/xine-engine/osd.c
--- xine-lib.ori/src/xine-engine/osd.c	2011-12-17 07:16:56.000000000 +0100
+++ xine-lib/src/xine-engine/osd.c	2011-12-17 10:47:47.000000000 +0100
@@ -511,6 +511,10 @@
   return _osd_show(osd, vpts, 1);
 }
 
+static int osd_show_gui_scaled (osd_object_t *osd, int64_t vpts) {
+  return _osd_show(osd, vpts, 2);
+}
+
 /*
  * send event to hide osd at given pts (0=now)
  * the object is not changed. there may be subsequent drawing  on it.
@@ -1917,6 +1921,7 @@
   this->draw_bitmap        = osd_draw_bitmap;
   this->set_argb_buffer    = osd_set_argb_buffer;
   this->show_unscaled      = osd_show_unscaled;
+  this->show_scaled        = osd_show_gui_scaled;
   this->get_capabilities   = osd_get_capabilities;
   this->set_extent         = osd_set_extent;
   this->set_video_window   = osd_set_video_window;
diff -Naur xine-lib.ori/src/xine-engine/video_out.c xine-lib/src/xine-engine/video_out.c
--- xine-lib.ori/src/xine-engine/video_out.c	2011-12-17 07:16:56.000000000 +0100
+++ xine-lib/src/xine-engine/video_out.c	2011-12-17 10:47:47.000000000 +0100
@@ -143,7 +143,7 @@
 
   /* pts value when decoder delivered last video frame */
   int64_t                   last_delivery_pts;
-
+  int64_t                   last_pts;
 
   video_overlay_manager_t  *overlay_source;
 
@@ -151,6 +151,7 @@
 
   int                       current_width, current_height;
   int64_t                   current_duration;
+  int                       framerate;
   int                       frame_drop_limit_max;
   int                       frame_drop_limit;
   int                       frame_drop_cpt;
@@ -754,6 +755,24 @@
   this->current_height = img->height;
 
   if (stream) {
+
+    int new_framerate = img->duration==0?0:90000*1000/img->duration;
+    if (this->framerate != new_framerate) {
+      this->framerate = new_framerate;
+
+      xine_event_t event;
+      xine_framerate_data_t data;
+      event.type = XINE_EVENT_FRAMERATE_CHANGE;
+      event.stream = stream;
+      event.data = &data;
+      event.data_length = sizeof(data);
+      data.framerate = this->framerate;
+      xine_event_send( stream, &event );
+    }
+
+    if (img->pts!=0)
+      this->last_pts = img->pts;
+
     _x_refcounter_inc(stream->refcounter);
     _x_extra_info_merge( img->extra_info, stream->video_decoder_extra_info );
     stream->metronom->got_video_frame (stream->metronom, img);
@@ -1260,6 +1279,7 @@
       pthread_mutex_unlock( &this->free_img_buf_queue->mutex );
       if( img ) {
         img->vpts = cur_vpts;
+        img->duration = DEFAULT_FRAME_DURATION;
         /* extra info of the backup is thrown away, because it is not up to date */
         _x_extra_info_reset(img->extra_info);
         img->future_frame = NULL;
@@ -1799,6 +1819,10 @@
     pthread_mutex_unlock(&this->streams_lock);
     break;
 
+  case VO_PROP_LAST_PTS:
+    ret = (int)&this->last_pts;
+    break;
+
   /*
    * handle XINE_PARAM_xxx properties (convert from driver's range)
    */
diff -Naur xine-lib.ori/src/xine-engine/xine_interface.c xine-lib/src/xine-engine/xine_interface.c
--- xine-lib.ori/src/xine-engine/xine_interface.c	2011-12-17 07:16:56.000000000 +0100
+++ xine-lib/src/xine-engine/xine_interface.c	2011-12-17 10:47:47.000000000 +0100
@@ -825,6 +825,10 @@
   this->osd.renderer->show_unscaled(&this->osd, vpts);
 }
 
+void xine_osd_show_scaled(xine_osd_t *this, int64_t vpts) {
+  this->osd.renderer->show_scaled(&this->osd, vpts);
+}
+
 void xine_osd_hide(xine_osd_t *this, int64_t vpts) {
   this->osd.renderer->hide(&this->osd, vpts);
 }
diff -Naur xine-lib.ori/version.sh xine-lib/version.sh
--- xine-lib.ori/version.sh	2011-12-17 07:16:56.000000000 +0100
+++ xine-lib/version.sh	2011-12-17 10:47:47.000000000 +0100
@@ -39,7 +39,7 @@
 XINE_LT_REVISION=0
 XINE_LT_AGE=0
 
-test -f "`dirname $0`/.cvsversion" && XINE_VERSION_SUFFIX="hg"
+test -f "`dirname $0`/.cvsversion" && XINE_VERSION_SUFFIX="openpli-e2"
 XINE_VERSION_SPEC="${XINE_VERSION_MAJOR}.${XINE_VERSION_MINOR}.${XINE_VERSION_SUB}${XINE_VERSION_PATCH}${XINE_VERSION_SUFFIX}"
 
 ####
